(CurryInfo (ModuleInfo "List" "Michael Hanus, Bjoern Peemoeller" "Library with some useful operations on lists.\n\n") [(FunctionInfo "elemIndex" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Maybe") [(TCons ("Prelude","Int") [])]))) "List" "Returns the index `i` of the first occurrence of an element in a list\nas `(Just i)`, otherwise `Nothing` is returned.\n" False UnknownFR),(FunctionInfo "elemIndices" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "List" "Returns the list of indices of occurrences of an element in a list.\n" False UnknownFR),(FunctionInfo "find" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Maybe") [(TVar 0)]))) "List" "Returns the first element `e` of a list satisfying a predicate as `(Just e)`,\notherwise `Nothing` is returned.\n" False UnknownFR),(FunctionInfo "findIndex" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Maybe") [(TCons ("Prelude","Int") [])]))) "List" "Returns the index `i` of the first occurrences of a list element\nsatisfying a predicate as `(Just i)`, otherwise `Nothing` is returned.\n" False UnknownFR),(FunctionInfo "findIndices" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "List" "Returns the list of indices of list elements satisfying a predicate.\n" False UnknownFR),(FunctionInfo "nub" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])) "List" "Removes all duplicates in the argument list.\n" False UnknownFR),(FunctionInfo "nubBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Removes all duplicates in the argument list according to an\nequivalence relation.\n" False KnownFlex),(FunctionInfo "delete" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Deletes the first occurrence of an element in a list.\n" False UnknownFR),(FunctionInfo "deleteBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])))) "List" "Deletes the first occurrence of an element in a list\naccording to an equivalence relation.\n" False ConflictFR),(FunctionInfo "\\\\" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Computes the difference of two lists.\n" False UnknownFR),(FunctionInfo "union" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Computes the union of two lists.\n" False ConflictFR),(FunctionInfo "unionBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])))) "List" "Computes the union of two lists according to the given equivalence relation\n" False UnknownFR),(FunctionInfo "intersect" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Computes the intersection of two lists.\n" False ConflictFR),(FunctionInfo "intersectBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])))) "List" "Computes the intersection of two lists\naccording to the given equivalence relation\n" False KnownFlex),(FunctionInfo "intersperse" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Puts a separator element between all elements in a list.\n\nExample: `(intersperse 9 [1,2,3,4]) = [1,9,2,9,3,9,4]`\n" False KnownFlex),(FunctionInfo "intercalate" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "`intercalate xs xss` is equivalent to `(concat (intersperse xs xss))`.\nIt inserts the list `xs` in between the lists in `xss` and\nconcatenates the result.\n" False UnknownFR),(FunctionInfo "transpose" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])])) "List" "Transposes the rows and columns of the argument.\n\nExample: `(transpose [[1,2,3],[4,5,6]]) = [[1,4],[2,5],[3,6]]`\n" False KnownFlex),(FunctionInfo "permutations" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])])) "List" "Returns the list of all permutations of the argument.\n" False UnknownFR),(FunctionInfo "partition" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TVar 0)]),(TCons ("Prelude","[]") [(TVar 0)])]))) "List" "Partitions a list into a pair of lists where the first list\ncontains those elements that satisfy the predicate argument\nand the second list contains the remaining arguments.\n\nExample: `(partition (<4) [8,1,5,2,4,3]) = ([1,2,3],[8,5,4])`\n" False UnknownFR),(FunctionInfo "group" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])])) "List" "Splits the list argument into a list of lists of equal adjacent\nelements.\n\nExample: `(group [1,2,2,3,3,3,4]) = [[1],[2,2],[3,3,3],[4]]`\n" False UnknownFR),(FunctionInfo "groupBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])]))) "List" "Splits the list argument into a list of lists of related adjacent\nelements.\n" False KnownFlex),(FunctionInfo "splitOn" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])]))) "List" "Breaks the second list argument into pieces separated by the first\nlist argument, consuming the delimiter. An empty delimiter is\ninvalid, and will cause an error to be raised.\n" False KnownFlex),(FunctionInfo "split" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])]))) "List" "Splits a list into components delimited by separators,\nwhere the predicate returns True for a separator element.\nThe resulting components do not contain the separators.\nTwo adjacent separators result in an empty component in the output.\n\n> split (=='a') \"aabbaca\" == [\"\",\"\",\"bb\",\"c\",\"\"]\n> split (=='a') \"\"        == [\"\"]\n" False ConflictFR),(FunctionInfo "inits" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])])) "List" "Returns all initial segments of a list, starting with the shortest.\nExample: `inits [1,2,3] == [[],[1],[1,2],[1,2,3]]`\n" False KnownFlex),(FunctionInfo "tails" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])])) "List" "Returns all final segments of a list, starting with the longest.\nExample: `tails [1,2,3] == [[1,2,3],[2,3],[3],[]]`\n" False KnownFlex),(FunctionInfo "replace" (FuncType (TVar 0) (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])))) "List" "Replaces an element in a list.\n" False ConflictFR),(FunctionInfo "isPrefixOf" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "List" "Checks whether a list is a prefix of another.\n" False KnownFlex),(FunctionInfo "isSuffixOf" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "List" "Checks whether a list is a suffix of another.\n" False UnknownFR),(FunctionInfo "isInfixOf" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "List" "Checks whether a list is contained in another.\n" False UnknownFR),(FunctionInfo "sortBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "Sorts a list w.r.t. an ordering relation by the insertion method.\n" False UnknownFR),(FunctionInfo "insertBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])))) "List" "Inserts an object into a list according to an ordering relation.\n" False ConflictFR),(FunctionInfo "last" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0)) "List" "Returns the last element of a non-empty list.\n" False KnownFlex),(FunctionInfo "init" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])) "List" "Returns the input list with the last element removed.\n" False KnownFlex),(FunctionInfo "sum" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]) (TCons ("Prelude","Int") [])) "List" "Returns the sum of a list of integers.\n" False UnknownFR),(FunctionInfo "product" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]) (TCons ("Prelude","Int") [])) "List" "Returns the product of a list of integers.\n" False UnknownFR),(FunctionInfo "maximum" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0)) "List" "Returns the maximum of a non-empty list.\n" False KnownFlex),(FunctionInfo "maximumBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Ordering") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0))) "List" "Returns the maximum of a non-empty list\naccording to the given comparison function\n" False KnownFlex),(FunctionInfo "minimum" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0)) "List" "Returns the minimum of a non-empty list.\n" False KnownFlex),(FunctionInfo "minimumBy" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Ordering") []))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0))) "List" "Returns the minimum of a non-empty list\naccording to the given comparison function\n" False KnownFlex),(FunctionInfo "scanl" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 0))) (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (TCons ("Prelude","[]") [(TVar 0)])))) "List" "`scanl` is similar to `foldl`, but returns a list of successive\nreduced values from the left:\n  scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]\n" False KnownRigid),(FunctionInfo "scanl1" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "`scanl1` is a variant of `scanl` that has no starting value argument:\n scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]\n" False KnownFlex),(FunctionInfo "scanr" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 1))) (FuncType (TVar 1) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 1)])))) "List" "`scanr` is the right-to-left dual of `scanl`.\n" False KnownFlex),(FunctionInfo "scanr1" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "List" "`scanr1` is a variant of `scanr` that has no starting value argument.\n" False KnownFlex),(FunctionInfo "mapAccumL" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TCons ("Prelude","(,)") [(TVar 0),(TVar 2)]))) (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","[]") [(TVar 2)])])))) "List" "The `mapAccumL` function behaves like a combination of `map` and\n`foldl`; it applies a function to each element of a list, passing\nan accumulating parameter from left to right, and returning a final\nvalue of this accumulator together with the new list.\n" False KnownFlex),(FunctionInfo "mapAccumR" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TCons ("Prelude","(,)") [(TVar 0),(TVar 2)]))) (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","[]") [(TVar 2)])])))) "List" "The `mapAccumR` function behaves like a combination of `map` and\n`foldr`; it applies a function to each element of a list, passing\nan accumulating parameter from right to left, and returning a final\nvalue of this accumulator together with the new list.\n" False KnownFlex),(FunctionInfo "cycle" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])) "List" "Builds an infinite list from a finite one.\n" False KnownFlex),(FunctionInfo "unfoldr" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Maybe") [(TCons ("Prelude","(,)") [(TVar 1),(TVar 0)])])) (FuncType (TVar 0) (TCons ("Prelude","[]") [(TVar 1)]))) "List" "Builds a list from a seed value.\n" False KnownRigid)] [])