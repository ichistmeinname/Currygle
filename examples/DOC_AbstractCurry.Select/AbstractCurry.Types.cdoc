(CurryInfo (ModuleInfo "AbstractCurry.Types" "Michael Hanus, Bj\246rn Peem\246ller" "This library contains a definition for representing Curry programs\nin Curry and an I/O action to read Curry programs and\ntransform them into this abstract representation.\n\nNote this defines a slightly new format for AbstractCurry\nin comparison to the first proposal of 2003.\n\nAssumption: an abstract Curry program is stored in file with\nextension .acy\n\n") [(FunctionInfo "version" (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) "AbstractCurry.Types" "Current version of AbstractCurry\n" False UnknownFR),(FunctionInfo "pre" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])) "AbstractCurry.Types" "Converts a string into a qualified name of the Prelude.\n" False UnknownFR)] [(TypeInfo "MName" [(("AbstractCurry.Types","MName"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "AbstractCurry.Types" "A module name.\n" True),(TypeInfo "QName" [(("AbstractCurry.Types","QName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry.Types" "The data type for representing qualified names.\nIn AbstractCurry all names are qualified to avoid name clashes.\nThe first component is the module name and the second component the\nunqualified name as it occurs in the source program.\nAn exception are locally defined names where the module name is\nthe empty string (to avoid name clashes with a globally defined name).\n" True),(TypeInfo "CTVarIName" [(("AbstractCurry.Types","CTVarIName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry.Types" "The type for representing type variables.\nThey are represented by (i,n) where i is a type variable index\nwhich is unique inside a function and n is a name (if possible,\nthe name written in the source program).\n" True),(TypeInfo "CField" [(("AbstractCurry.Types","CField"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TVar 0)])])] [0] "AbstractCurry.Types" "Labeled record fields\n" True),(TypeInfo "Arity" [(("AbstractCurry.Types","Arity"),[(TCons ("Prelude","Int") [])])] [] "AbstractCurry.Types" "Function arity\n" True),(TypeInfo "CVarIName" [(("AbstractCurry.Types","CVarIName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry.Types" "Data types for representing object variables.\nObject variables occurring in expressions are represented by (Var i)\nwhere i is a variable index.\n" True),(TypeInfo "CVisibility" [(("AbstractCurry.Types","Public"),[]),(("AbstractCurry.Types","Private"),[])] [] "AbstractCurry.Types" "Data type to specify the visibility of various entities.\n" False),(TypeInfo "CurryProg" [(("AbstractCurry.Types","CurryProg"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CTypeDecl") [])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CFuncDecl") [])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","COpDecl") [])])])] [] "AbstractCurry.Types" "Data type for representing a Curry module in the intermediate form.\nA value of this data type has the form\n\n    (CProg modname imports typedecls functions opdecls)\n\nwhere modname: name of this module,\n      imports: list of modules names that are imported,\n      typedecls: Type declarations\n      functions: Function declarations\n      opdecls: Operator precedence declarations\n" False),(TypeInfo "CTypeDecl" [(("AbstractCurry.Types","CType"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CConsDecl") [])])]),(("AbstractCurry.Types","CTypeSyn"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(TCons ("AbstractCurry.Types","CTypeExpr") [])]),(("AbstractCurry.Types","CNewType"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(TCons ("AbstractCurry.Types","CConsDecl") [])])] [] "AbstractCurry.Types" "Data type for representing definitions of algebraic data types\nand type synonyms.\n\nA data type definition of the form\n\n    data t x1...xn = ...| c t1....tkc |...\n\nis represented by the Curry term\n\n    (CType t v [i1,...,in] [...(CCons c kc v [t1,...,tkc])...])\n\nwhere each `ij` is the index of the type variable `xj`.\n\nNote: the type variable indices are unique inside each type declaration\n      and are usually numbered from 0\n\nThus, a data type declaration consists of the name of the data type,\na list of type parameters and a list of constructor declarations.\n" False),(TypeInfo "CConsDecl" [(("AbstractCurry.Types","CCons"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CTypeExpr") [])])]),(("AbstractCurry.Types","CRecord"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CFieldDecl") [])])])] [] "AbstractCurry.Types" "A constructor declaration consists of the name of the\nconstructor and a list of the argument types of the constructor.\nThe arity equals the number of types.\n" False),(TypeInfo "CFieldDecl" [(("AbstractCurry.Types","CField"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("AbstractCurry.Types","CTypeExpr") [])])] [] "AbstractCurry.Types" "A record field declaration consists of the name of the\nthe label, the visibility and its corresponding type.\n" False),(TypeInfo "CTypeExpr" [(("AbstractCurry.Types","CTVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry.Types","CFuncType"),[(TCons ("AbstractCurry.Types","CTypeExpr") []),(TCons ("AbstractCurry.Types","CTypeExpr") [])]),(("AbstractCurry.Types","CTCons"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CTypeExpr") [])])])] [] "AbstractCurry.Types" "Type expression.\nA type expression is either a type variable, a function type,\nor a type constructor application.\n\nNote: the names of the predefined type constructors are\n      \"Int\", \"Float\", \"Bool\", \"Char\", \"IO\", \"Success\",\n      \"()\" (unit type), \"(,...,)\" (tuple types), \"[]\" (list type)\n" False),(TypeInfo "COpDecl" [(("AbstractCurry.Types","COp"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CFixity") []),(TCons ("Prelude","Int") [])])] [] "AbstractCurry.Types" "Data type for operator declarations.\nAn operator declaration \"fix p n\" in Curry corresponds to the\nAbstractCurry term (COp n fix p).\n" False),(TypeInfo "CFixity" [(("AbstractCurry.Types","CInfixOp"),[]),(("AbstractCurry.Types","CInfixlOp"),[]),(("AbstractCurry.Types","CInfixrOp"),[])] [] "AbstractCurry.Types" "Data type for operator associativity\n" False),(TypeInfo "CFuncDecl" [(("AbstractCurry.Types","CFunc"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("AbstractCurry.Types","CTypeExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CRule") [])])]),(("AbstractCurry.Types","CmtFunc"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("AbstractCurry.Types","CVisibility") []),(TCons ("AbstractCurry.Types","CTypeExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CRule") [])])])] [] "AbstractCurry.Types" "Data type for representing function declarations.\n\nA function declaration in AbstractCurry is a term of the form\n\n<code>(CFunc name arity visibility type (CRules eval [CRule rule1,...,rulek]))</code>\n\nand represents the function <code>name</code> defined by the rules\n<code>rule1,...,rulek</code>.\n\nNote: the variable indices are unique inside each rule\n\nThus, a function declaration consists of the name, arity, type, and\na list of rules.\n\nA function declaration with the constructor <code>CmtFunc</code>\nis similarly to <code>CFunc</code> but has a comment\nas an additional first argument. This comment could be used\nby pretty printers that generate a readable Curry program\ncontaining documentation comments.\n" False),(TypeInfo "CRule" [(("AbstractCurry.Types","CRule"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CPattern") [])]),(TCons ("AbstractCurry.Types","CRhs") [])])] [] "AbstractCurry.Types" "The general form of a function rule. It consists of a list of patterns\n(left-hand side) and the right-hand side for these patterns.\n" False),(TypeInfo "CRhs" [(("AbstractCurry.Types","CSimpleRhs"),[(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CLocalDecl") [])])]),(("AbstractCurry.Types","CGuardedRhs"),[(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("AbstractCurry.Types","CExpr") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CLocalDecl") [])])])] [] "AbstractCurry.Types" "Right-hand-side of a 'CRule' or a `case` expression.\nIt is either a simple unconditional right-hand side or\na list of guards with their corresponding right-hand sides, and\na list of local declarations.\n" False),(TypeInfo "CLocalDecl" [(("AbstractCurry.Types","CLocalFunc"),[(TCons ("AbstractCurry.Types","CFuncDecl") [])]),(("AbstractCurry.Types","CLocalPat"),[(TCons ("AbstractCurry.Types","CPattern") []),(TCons ("AbstractCurry.Types","CRhs") [])]),(("AbstractCurry.Types","CLocalVars"),[(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])])] [] "AbstractCurry.Types" "Data type for representing local (let/where) declarations\n" False),(TypeInfo "CPattern" [(("AbstractCurry.Types","CPVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry.Types","CPLit"),[(TCons ("AbstractCurry.Types","CLiteral") [])]),(("AbstractCurry.Types","CPComb"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CPattern") [])])]),(("AbstractCurry.Types","CPAs"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CPattern") [])]),(("AbstractCurry.Types","CPFuncComb"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CPattern") [])])]),(("AbstractCurry.Types","CPLazy"),[(TCons ("AbstractCurry.Types","CPattern") [])]),(("AbstractCurry.Types","CPRecord"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CPattern") [])])])])] [] "AbstractCurry.Types" "Data type for representing pattern expressions.\n" False),(TypeInfo "CExpr" [(("AbstractCurry.Types","CVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry.Types","CLit"),[(TCons ("AbstractCurry.Types","CLiteral") [])]),(("AbstractCurry.Types","CSymbol"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry.Types","CApply"),[(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("AbstractCurry.Types","CExpr") [])]),(("AbstractCurry.Types","CLambda"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CPattern") [])]),(TCons ("AbstractCurry.Types","CExpr") [])]),(("AbstractCurry.Types","CLetDecl"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CLocalDecl") [])]),(TCons ("AbstractCurry.Types","CExpr") [])]),(("AbstractCurry.Types","CDoExpr"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CStatement") [])])]),(("AbstractCurry.Types","CListComp"),[(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CStatement") [])])]),(("AbstractCurry.Types","CCase"),[(TCons ("AbstractCurry.Types","CCaseType") []),(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("AbstractCurry.Types","CPattern") []),(TCons ("AbstractCurry.Types","CRhs") [])])])]),(("AbstractCurry.Types","CTyped"),[(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("AbstractCurry.Types","CTypeExpr") [])]),(("AbstractCurry.Types","CRecConstr"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CExpr") [])])])]),(("AbstractCurry.Types","CRecUpdate"),[(TCons ("AbstractCurry.Types","CExpr") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry.Types","CExpr") [])])])])] [] "AbstractCurry.Types" "Data type for representing Curry expressions.\n" False),(TypeInfo "CLiteral" [(("AbstractCurry.Types","CIntc"),[(TCons ("Prelude","Int") [])]),(("AbstractCurry.Types","CFloatc"),[(TCons ("Prelude","Float") [])]),(("AbstractCurry.Types","CCharc"),[(TCons ("Prelude","Char") [])]),(("AbstractCurry.Types","CStringc"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "AbstractCurry.Types" "Data type for representing literals occurring in an expression.\nIt is either an integer, a float, or a character constant.\n" False),(TypeInfo "CStatement" [(("AbstractCurry.Types","CSExpr"),[(TCons ("AbstractCurry.Types","CExpr") [])]),(("AbstractCurry.Types","CSPat"),[(TCons ("AbstractCurry.Types","CPattern") []),(TCons ("AbstractCurry.Types","CExpr") [])]),(("AbstractCurry.Types","CSLet"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry.Types","CLocalDecl") [])])])] [] "AbstractCurry.Types" "Data type for representing statements in do expressions and\nlist comprehensions.\n" False),(TypeInfo "CCaseType" [(("AbstractCurry.Types","CRigid"),[]),(("AbstractCurry.Types","CFlex"),[])] [] "AbstractCurry.Types" "Type of case expressions\n" False)])