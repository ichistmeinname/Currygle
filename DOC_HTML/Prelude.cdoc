(CurryInfo (ModuleInfo "Prelude" [] "The standard prelude of Curry.\nAll top-level functions defined in this module\nare always available in any Curry program.\n") [(FunctionInfo "." (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (FuncType (TVar 2) (TVar 0)) (FuncType (TVar 2) (TVar 1)))) "Prelude" "Function composition.\n" False UnknownFR),(FunctionInfo "id" (FuncType (TVar 0) (TVar 0)) "Prelude" "Identity function.\n" False UnknownFR),(FunctionInfo "const" (FuncType (TVar 0) (FuncType (TVar 1) (TVar 0))) "Prelude" "Constant function.\n" False UnknownFR),(FunctionInfo "curry" (FuncType (FuncType (TCons ("Prelude","(,)") [(TVar 0),(TVar 1)]) (TVar 2)) (FuncType (TVar 0) (FuncType (TVar 1) (TVar 2)))) "Prelude" "Converts an uncurried function to a curried function.\n" False UnknownFR),(FunctionInfo "uncurry" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 2))) (FuncType (TCons ("Prelude","(,)") [(TVar 0),(TVar 1)]) (TVar 2))) "Prelude" "Converts an curried function to a function on pairs.\n" False KnownFlex),(FunctionInfo "flip" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 2))) (FuncType (TVar 1) (FuncType (TVar 0) (TVar 2)))) "Prelude" "(flip f) is identical to f but with the order of arguments reversed.\n" False UnknownFR),(FunctionInfo "until" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (FuncType (TVar 0) (TVar 0)) (FuncType (TVar 0) (TVar 0)))) "Prelude" "Repeats application of a function until a predicate holds.\n" False KnownRigid),(FunctionInfo "seq" (FuncType (TVar 0) (FuncType (TVar 1) (TVar 1))) "Prelude" "Evaluates the first argument to head normal form (which could also\nbe a free variable) and returns the second argument.\n" False UnknownFR),(FunctionInfo "ensureNotFree" (FuncType (TVar 0) (TVar 0)) "Prelude" "Evaluates the argument to head normal form and returns it.\nSuspends until the result is bound to a non-variable term.\n" False UnknownFR),(FunctionInfo "ensureSpine" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])) "Prelude" "Evaluates the argument to spine form and returns it.\nSuspends until the result is bound to a non-variable spine.\n" False UnknownFR),(FunctionInfo "$" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TVar 0) (TVar 1))) "Prelude" "Right-associative application.\n" False UnknownFR),(FunctionInfo "$!" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TVar 0) (TVar 1))) "Prelude" "Right-associative application with strict evaluation of its argument.\n" False UnknownFR),(FunctionInfo "$!!" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TVar 0) (TVar 1))) "Prelude" "Right-associative application with strict evaluation of its argument\nto normal form.\n" False UnknownFR),(FunctionInfo "$#" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TVar 0) (TVar 1))) "Prelude" "Right-associative application with strict evaluation of its argument\nto a non-variable term.\n" False UnknownFR),(FunctionInfo "$##" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TVar 0) (TVar 1))) "Prelude" "Right-associative application with strict evaluation of its argument\nto ground normal form.\n" False UnknownFR),(FunctionInfo "error" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TVar 0)) "Prelude" "Aborts the execution with an error message.\n" False UnknownFR),(FunctionInfo "prim_error" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TVar 0)) "Prelude" [] False UnknownFR),(FunctionInfo "failed" (TVar 0) "Prelude" "A non-reducible polymorphic function.\nIt is useful to express a failure in a search branch of the execution.\nIt could be defined by: <code>failed = head []</code>\n" False UnknownFR),(FunctionInfo "&&" (FuncType (TCons ("Prelude","Bool") []) (FuncType (TCons ("Prelude","Bool") []) (TCons ("Prelude","Bool") []))) "Prelude" "Sequential conjunction on Booleans.\n" False KnownFlex),(FunctionInfo "||" (FuncType (TCons ("Prelude","Bool") []) (FuncType (TCons ("Prelude","Bool") []) (TCons ("Prelude","Bool") []))) "Prelude" "Sequential disjunction on Booleans.\n" False KnownFlex),(FunctionInfo "not" (FuncType (TCons ("Prelude","Bool") []) (TCons ("Prelude","Bool") [])) "Prelude" "Negation on Booleans.\n" False KnownFlex),(FunctionInfo "otherwise" (TCons ("Prelude","Bool") []) "Prelude" "Useful name for the last condition in a sequence of conditional equations.\n" False UnknownFR),(FunctionInfo "if_then_else" (FuncType (TCons ("Prelude","Bool") []) (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0)))) "Prelude" "The standard conditional. It suspends if the condition is a free variable.\n" False KnownRigid),(FunctionInfo "==" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) "Prelude" "Equality on finite ground data terms.\n" False UnknownFR),(FunctionInfo "/=" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) "Prelude" "Disequality.\n" False UnknownFR),(FunctionInfo "compare" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Ordering") []))) "Prelude" "Comparison of arbitrary ground data terms.\nData constructors are compared in the order of their definition\nin the datatype declarations and recursively in the arguments.\n" False UnknownFR),(FunctionInfo "<" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) "Prelude" "Less-than on ground data terms.\n" False KnownRigid),(FunctionInfo ">" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) "Prelude" "Greater-than on ground data terms.\n" False KnownRigid),(FunctionInfo "<=" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) "Prelude" "Less-or-equal on ground data terms.\n" False UnknownFR),(FunctionInfo ">=" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) "Prelude" "Greater-or-equal on ground data terms.\n" False UnknownFR),(FunctionInfo "max" (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) "Prelude" "Maximum of ground data terms.\n" False KnownRigid),(FunctionInfo "min" (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) "Prelude" "Minimum of ground data terms.\n" False KnownRigid),(FunctionInfo "fst" (FuncType (TCons ("Prelude","(,)") [(TVar 0),(TVar 1)]) (TVar 0)) "Prelude" "Selects the first component of a pair.\n" False KnownFlex),(FunctionInfo "snd" (FuncType (TCons ("Prelude","(,)") [(TVar 0),(TVar 1)]) (TVar 1)) "Prelude" "Selects the second component of a pair.\n" False KnownFlex),(FunctionInfo "head" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0)) "Prelude" "Computes the first element of a list.\n" False KnownFlex),(FunctionInfo "tail" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])) "Prelude" "Computes the remaining elements of a list.\n" False KnownFlex),(FunctionInfo "null" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") [])) "Prelude" "Is a list empty?\n" False KnownFlex),(FunctionInfo "++" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Concatenates two lists.\nSince it is flexible, it could be also used to split a list\ninto two sublists etc.\n" False KnownFlex),(FunctionInfo "length" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Int") [])) "Prelude" "Computes the length of a list.\n" False KnownFlex),(FunctionInfo "!!" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","Int") []) (TVar 0))) "Prelude" "List index (subscript) operator, head has index 0.\n" False ConflictFR),(FunctionInfo "map" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 1)]))) "Prelude" "Map a function on all elements of a list.\n" False KnownFlex),(FunctionInfo "foldl" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 0))) (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (TVar 0)))) "Prelude" "Accumulates all list elements by applying a binary operator from\nleft to right. Thus,\n<CODE>foldl f z [x1,x2,...,xn] = (...((z `f` x1) `f` x2) ...) `f` xn</CODE>\n" False KnownFlex),(FunctionInfo "foldl1" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0))) "Prelude" "Accumulates a non-empty list from left to right.\n" False KnownFlex),(FunctionInfo "foldr" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 1))) (FuncType (TVar 1) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 1)))) "Prelude" "Accumulates all list elements by applying a binary operator from\nright to left. Thus,\n<CODE>foldr f z [x1,x2,...,xn] = (x1 `f` (x2 `f` ... (xn `f` z)...))</CODE>\n" False KnownFlex),(FunctionInfo "foldr1" (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TVar 0))) "Prelude" "Accumulates a non-empty list from right to left:\n" False KnownFlex),(FunctionInfo "filter" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Filters all elements satisfying a given predicate in a list.\n" False ConflictFR),(FunctionInfo "zip" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TVar 1)])]))) "Prelude" "Joins two lists into one list of pairs. If one input list is shorter than\nthe other, the additional elements of the longer list are discarded.\n" False KnownFlex),(FunctionInfo "zip3" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (FuncType (TCons ("Prelude","[]") [(TVar 2)]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TVar 0),(TVar 1),(TVar 2)])])))) "Prelude" "Joins three lists into one list of triples. If one input list is shorter\nthan the other, the additional elements of the longer lists are discarded.\n" False KnownFlex),(FunctionInfo "zipWith" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (TVar 2))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (TCons ("Prelude","[]") [(TVar 2)])))) "Prelude" "Joins two lists into one list by applying a combination function to\ncorresponding pairs of elements. Thus <CODE>zip = zipWith (,)</CODE>\n" False KnownFlex),(FunctionInfo "zipWith3" (FuncType (FuncType (TVar 0) (FuncType (TVar 1) (FuncType (TVar 2) (TVar 3)))) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (FuncType (TCons ("Prelude","[]") [(TVar 1)]) (FuncType (TCons ("Prelude","[]") [(TVar 2)]) (TCons ("Prelude","[]") [(TVar 3)]))))) "Prelude" "Joins three lists into one list by applying a combination function to\ncorresponding triples of elements. Thus <CODE>zip3 = zipWith3 (,,)</CODE>\n" False KnownFlex),(FunctionInfo "unzip" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TVar 1)])]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TVar 0)]),(TCons ("Prelude","[]") [(TVar 1)])])) "Prelude" "Transforms a list of pairs into a pair of lists.\n" False KnownFlex),(FunctionInfo "unzip3" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TVar 0),(TVar 1),(TVar 2)])]) (TCons ("Prelude","(,,)") [(TCons ("Prelude","[]") [(TVar 0)]),(TCons ("Prelude","[]") [(TVar 1)]),(TCons ("Prelude","[]") [(TVar 2)])])) "Prelude" "Transforms a list of triples into a triple of lists.\n" False KnownFlex),(FunctionInfo "concat" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TVar 0)])]) (TCons ("Prelude","[]") [(TVar 0)])) "Prelude" "Concatenates a list of lists into one list.\n" False UnknownFR),(FunctionInfo "concatMap" (FuncType (FuncType (TVar 0) (TCons ("Prelude","[]") [(TVar 1)])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 1)]))) "Prelude" "Maps a function from elements to lists and merges the result into one list.\n" False UnknownFR),(FunctionInfo "iterate" (FuncType (FuncType (TVar 0) (TVar 0)) (FuncType (TVar 0) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Infinite list of repeated applications of a function f to an element x.\nThus, <CODE>iterate f x = [x, f x, f (f x),...]</CODE>\n" False UnknownFR),(FunctionInfo "repeat" (FuncType (TVar 0) (TCons ("Prelude","[]") [(TVar 0)])) "Prelude" "Infinite list where all elements have the same value.\nThus, <CODE>repeat x = [x, x, x,...]</CODE>\n" False UnknownFR),(FunctionInfo "replicate" (FuncType (TCons ("Prelude","Int") []) (FuncType (TVar 0) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "List of length n where all elements have the same value.\n" False UnknownFR),(FunctionInfo "take" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Returns prefix of length n.\n" False KnownRigid),(FunctionInfo "drop" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Returns suffix without first n elements.\n" False KnownRigid),(FunctionInfo "splitAt" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TVar 0)]),(TCons ("Prelude","[]") [(TVar 0)])]))) "Prelude" "(splitAt n xs) is equivalent to (take n xs, drop n xs)\n" False KnownRigid),(FunctionInfo "takeWhile" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Returns longest prefix with elements satisfying a predicate.\n" False ConflictFR),(FunctionInfo "dropWhile" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)]))) "Prelude" "Returns suffix without takeWhile prefix.\n" False ConflictFR),(FunctionInfo "span" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TVar 0)]),(TCons ("Prelude","[]") [(TVar 0)])]))) "Prelude" "(span p xs) is equivalent to (takeWhile p xs, dropWhile p xs)\n" False ConflictFR),(FunctionInfo "break" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TVar 0)]),(TCons ("Prelude","[]") [(TVar 0)])]))) "Prelude" "(break p xs) is equivalent to (takeWhile (not.p) xs, dropWhile (not.p) xs).\nThus, it breaks a list at the first occurrence of an element satisfying p.\n" False UnknownFR),(FunctionInfo "lines" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])) "Prelude" "Breaks a string into a list of lines where a line is terminated at a\nnewline character. The resulting lines do not contain newline characters.\n" False KnownFlex),(FunctionInfo "unlines" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "Prelude" "Concatenates a list of strings with terminating newlines.\n" False UnknownFR),(FunctionInfo "words" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])) "Prelude" "Breaks a string into a list of words where the words are delimited by\nwhite spaces.\n" False KnownRigid),(FunctionInfo "unwords" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "Prelude" "Concatenates a list of strings with a blank between two strings.\n" False KnownRigid),(FunctionInfo "reverse" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TVar 0)])) "Prelude" "Reverses the order of all elements in a list.\n" False UnknownFR),(FunctionInfo "and" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Bool") [])]) (TCons ("Prelude","Bool") [])) "Prelude" "Computes the conjunction of a Boolean list.\n" False UnknownFR),(FunctionInfo "or" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Bool") [])]) (TCons ("Prelude","Bool") [])) "Prelude" "Computes the disjunction of a Boolean list.\n" False UnknownFR),(FunctionInfo "any" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "Prelude" "Is there an element in a list satisfying a given predicate?\n" False UnknownFR),(FunctionInfo "all" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Bool") [])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "Prelude" "Is a given predicate satisfied by all elements in a list?\n" False UnknownFR),(FunctionInfo "elem" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "Prelude" "Element of a list?\n" False UnknownFR),(FunctionInfo "notElem" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","Bool") []))) "Prelude" "Not element of a list?\n" False UnknownFR),(FunctionInfo "lookup" (FuncType (TVar 0) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TVar 1)])]) (TCons ("Prelude","Maybe") [(TVar 1)]))) "Prelude" "Looks up a key in an association list.\n" False ConflictFR),(FunctionInfo "enumFrom" (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])) "Prelude" "Generates an infinite sequence of ascending integers.\n" False UnknownFR),(FunctionInfo "enumFromThen" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "Prelude" "Generates an infinite sequence of integers with a particular in/decrement.\n" False UnknownFR),(FunctionInfo "enumFromTo" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "Prelude" "Generates a sequence of ascending integers.\n" False KnownRigid),(FunctionInfo "enumFromThenTo" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])))) "Prelude" "Generates a sequence of integers with a particular in/decrement.\n" False UnknownFR),(FunctionInfo "ord" (FuncType (TCons ("Prelude","Char") []) (TCons ("Prelude","Int") [])) "Prelude" "Converts a character into its ASCII value.\n" False UnknownFR),(FunctionInfo "prim_ord" (FuncType (TCons ("Prelude","Char") []) (TCons ("Prelude","Int") [])) "Prelude" [] False UnknownFR),(FunctionInfo "chr" (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Char") [])) "Prelude" "Converts an ASCII value into a character.\n" False UnknownFR),(FunctionInfo "prim_chr" (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Char") [])) "Prelude" [] False UnknownFR),(FunctionInfo "+" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" "Adds two integers.\n" False UnknownFR),(FunctionInfo "prim_Int_plus" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" [] False UnknownFR),(FunctionInfo "-" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" "Subtracts two integers.\n" False UnknownFR),(FunctionInfo "prim_Int_minus" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" [] False UnknownFR),(FunctionInfo "*" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" "Multiplies two integers.\n" False UnknownFR),(FunctionInfo "prim_Int_times" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" [] False UnknownFR),(FunctionInfo "div" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" "Integer division. The value is the integer quotient of its arguments\nand always truncated towards zero.\nThus, the value of <code>13 `div` 5</code> is <code>2</code>,\nand the value of <code>-15 `div` 4</code> is <code>-3</code>.\n" False UnknownFR),(FunctionInfo "prim_Int_div" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" [] False UnknownFR),(FunctionInfo "mod" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" "Integer remainder. The value is the remainder of the integer division and\nit obeys the rule <code>x `mod` y = x - y * (x `div` y)</code>.\nThus, the value of <code>13 `mod` 5</code> is <code>3</code>,\nand the value of <code>-15 `mod` 4</code> is <code>-3</code>.\n" False UnknownFR),(FunctionInfo "prim_Int_mod" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "Prelude" [] False UnknownFR),(FunctionInfo "negate" (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") [])) "Prelude" "Unary minus. Usually written as \"- e\".\n" False UnknownFR),(FunctionInfo "negateFloat" (FuncType (TCons ("Prelude","Float") []) (TCons ("Prelude","Float") [])) "Prelude" "Unary minus on Floats. Usually written as \"-e\".\n" False UnknownFR),(FunctionInfo "prim_negateFloat" (FuncType (TCons ("Prelude","Float") []) (TCons ("Prelude","Float") [])) "Prelude" [] False UnknownFR),(FunctionInfo "=:=" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Success") []))) "Prelude" "The equational constraint.\n(e1 =:= e2) is satisfiable if both sides e1 and e2 can be\nreduced to a unifiable data term (i.e., a term without defined\nfunction symbols).\n" False UnknownFR),(FunctionInfo "success" (TCons ("Prelude","Success") []) "Prelude" "The always satisfiable constraint.\n" False UnknownFR),(FunctionInfo "&" (FuncType (TCons ("Prelude","Success") []) (FuncType (TCons ("Prelude","Success") []) (TCons ("Prelude","Success") []))) "Prelude" "Concurrent conjunction on constraints.\nAn expression like (c1 & c2) is evaluated by evaluating\nthe constraints c1 and c2 in a concurrent manner.\n" False UnknownFR),(FunctionInfo "&>" (FuncType (TCons ("Prelude","Success") []) (FuncType (TVar 0) (TVar 0))) "Prelude" "Constrained expression.\nAn expression like (c &> e) is evaluated by first solving\nconstraint c and then evaluating e.\n" False UnknownFR),(FunctionInfo "maybe" (FuncType (TVar 0) (FuncType (FuncType (TVar 1) (TVar 0)) (FuncType (TCons ("Prelude","Maybe") [(TVar 1)]) (TVar 0)))) "Prelude" [] False KnownFlex),(FunctionInfo "either" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (FuncType (TVar 2) (TVar 1)) (FuncType (TCons ("Prelude","Either") [(TVar 0),(TVar 2)]) (TVar 1)))) "Prelude" [] False KnownFlex),(FunctionInfo ">>=" (FuncType (TCons ("Prelude","IO") [(TVar 0)]) (FuncType (FuncType (TVar 0) (TCons ("Prelude","IO") [(TVar 1)])) (TCons ("Prelude","IO") [(TVar 1)]))) "Prelude" "Sequential composition of actions.\n" False UnknownFR),(FunctionInfo "return" (FuncType (TVar 0) (TCons ("Prelude","IO") [(TVar 0)])) "Prelude" "The empty action that directly returns its argument.\n" False UnknownFR),(FunctionInfo ">>" (FuncType (TCons ("Prelude","IO") [(TVar 0)]) (FuncType (TCons ("Prelude","IO") [(TVar 1)]) (TCons ("Prelude","IO") [(TVar 1)]))) "Prelude" "Sequential composition of actions.\n" False UnknownFR),(FunctionInfo "done" (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]) "Prelude" "The empty action that returns nothing.\n" False UnknownFR),(FunctionInfo "putChar" (FuncType (TCons ("Prelude","Char") []) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "An action that puts its character argument on standard output.\n" False UnknownFR),(FunctionInfo "prim_putChar" (FuncType (TCons ("Prelude","Char") []) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" [] False UnknownFR),(FunctionInfo "getChar" (TCons ("Prelude","IO") [(TCons ("Prelude","Char") [])]) "Prelude" "An action that reads a character from standard output and returns it.\n" False UnknownFR),(FunctionInfo "readFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])) "Prelude" "An action that (lazily) reads a file and returns its contents.\n" False UnknownFR),(FunctionInfo "prim_readFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])) "Prelude" [] False UnknownFR),(FunctionInfo "prim_readFileContents" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "Prelude" [] False UnknownFR),(FunctionInfo "writeFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "Prelude" "An action that writes a file.\n" False UnknownFR),(FunctionInfo "prim_writeFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "Prelude" [] False UnknownFR),(FunctionInfo "appendFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "Prelude" "An action that appends a string to a file.\nIt behaves like writeFile if the file does not exist.\n" False UnknownFR),(FunctionInfo "prim_appendFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "Prelude" [] False UnknownFR),(FunctionInfo "putStr" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Action to print a string on stdout.\n" False KnownFlex),(FunctionInfo "putStrLn" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Action to print a string with a newline on stdout.\n" False UnknownFR),(FunctionInfo "getLine" (TCons ("Prelude","IO") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]) "Prelude" "Action to read a line from stdin.\n" False UnknownFR),(FunctionInfo "userError" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IOError") [])) "Prelude" "A user error value is created by providing a description of the\nerror situation as a string.\n" False UnknownFR),(FunctionInfo "ioError" (FuncType (TCons ("Prelude","IOError") []) (TCons ("Prelude","IO") [(TVar 0)])) "Prelude" "Raises an I/O exception with a given error value.\n" False KnownFlex),(FunctionInfo "showError" (FuncType (TCons ("Prelude","IOError") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "Prelude" "Shows an error values as a string.\n" False KnownFlex),(FunctionInfo "catch" (FuncType (TCons ("Prelude","IO") [(TVar 0)]) (FuncType (FuncType (TCons ("Prelude","IOError") []) (TCons ("Prelude","IO") [(TVar 0)])) (TCons ("Prelude","IO") [(TVar 0)]))) "Prelude" "Catches a possible error or failure during the execution of an\nI/O action. <code>(catch act errfun)</code> executes the I/O action\n<code>act</code>. If an exception or failure occurs\nduring this I/O action, the function <code>errfun</code> is applied\nto the error value.\n" False UnknownFR),(FunctionInfo "catchFail" (FuncType (TCons ("Prelude","IO") [(TVar 0)]) (FuncType (TCons ("Prelude","IO") [(TVar 0)]) (TCons ("Prelude","IO") [(TVar 0)]))) "Prelude" "Catches a possible failure during the execution of an I/O action.\n<code>(catchFail act err)</code>:\napply action <code>act</code> and, if it fails or raises an exception,\nprint a corresponding error message and apply action <code>err</code>.\n" False UnknownFR),(FunctionInfo "show" (FuncType (TVar 0) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "Prelude" "Converts an arbitrary term into an external string representation.\n" False UnknownFR),(FunctionInfo "prim_show" (FuncType (TVar 0) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "Prelude" [] False UnknownFR),(FunctionInfo "print" (FuncType (TVar 0) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Converts a term into a string and prints it.\n" False UnknownFR),(FunctionInfo "doSolve" (FuncType (TCons ("Prelude","Success") []) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Solves a constraint as an I/O action.\nNote: the constraint should be always solvable in a deterministic way\n" False UnknownFR),(FunctionInfo "sequenceIO" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","IO") [(TVar 0)])]) (TCons ("Prelude","IO") [(TCons ("Prelude","[]") [(TVar 0)])])) "Prelude" "Executes a sequence of I/O actions and collects all results in a list.\n" False KnownFlex),(FunctionInfo "sequenceIO_" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","IO") [(TVar 0)])]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Executes a sequence of I/O actions and ignores the results.\n" False UnknownFR),(FunctionInfo "mapIO" (FuncType (FuncType (TVar 0) (TCons ("Prelude","IO") [(TVar 1)])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","IO") [(TCons ("Prelude","[]") [(TVar 1)])]))) "Prelude" "Maps an I/O action function on a list of elements.\nThe results of all I/O actions are collected in a list.\n" False UnknownFR),(FunctionInfo "mapIO_" (FuncType (FuncType (TVar 0) (TCons ("Prelude","IO") [(TVar 1)])) (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "Prelude" "Maps an I/O action function on a list of elements.\nThe results of all I/O actions are ignored.\n" False UnknownFR),(FunctionInfo "?" (FuncType (TVar 0) (FuncType (TVar 0) (TVar 0))) "Prelude" "Non-deterministic choice <EM>par excellence</EM>.\nThe value of <EM>x ? y</EM> is either <EM>x</EM> or <EM>y</EM>.\n" True UnknownFR),(FunctionInfo "unknown" (TVar 0) "Prelude" "Evaluates to a fresh free variable.\n" False UnknownFR),(FunctionInfo "getAllValues" (FuncType (TVar 0) (TCons ("Prelude","IO") [(TCons ("Prelude","[]") [(TVar 0)])])) "Prelude" "Gets all values of an expression (currently, via an incomplete\ndepth-first strategy). Conceptually, all values are computed\non a copy of the expression, i.e., the evaluation of the expression\ndoes not share any results. Moreover, the evaluation suspends\nas long as the expression contains unbound variables.\nSimilar to Prolog's findall.\n" False UnknownFR),(FunctionInfo "getSomeValue" (FuncType (TVar 0) (TCons ("Prelude","IO") [(TVar 0)])) "Prelude" "Gets a value of an expression (currently, via an incomplete\ndepth-first strategy). The expression must have a value, otherwise\nthe computation fails. Conceptually, the value is computed on a copy\nof the expression, i.e., the evaluation of the expression does not share\nany results. Moreover, the evaluation suspends as long as the expression\ncontains unbound variables.\n" False UnknownFR),(FunctionInfo "try" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TCons ("Prelude","[]") [(FuncType (TVar 0) (TCons ("Prelude","Success") []))])) "Prelude" "Basic search control operator.\n" False UnknownFR),(FunctionInfo "inject" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (FuncType (TVar 0) (TCons ("Prelude","Success") [])))) "Prelude" "Inject operator which adds the application of the unary\nprocedure p to the search variable to the search goal\ntaken from Oz. p x comes before g x to enable a test+generate\nform in a sequential implementation.\n" False UnknownFR),(FunctionInfo "solveAll" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TCons ("Prelude","[]") [(FuncType (TVar 0) (TCons ("Prelude","Success") []))])) "Prelude" "Computes all solutions via a a depth-first strategy.\n" False UnknownFR),(FunctionInfo "solveAll2" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TCons ("Prelude","[]") [(FuncType (TVar 0) (TCons ("Prelude","Success") []))])) "Prelude" [] False UnknownFR),(FunctionInfo "once" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (FuncType (TVar 0) (TCons ("Prelude","Success") []))) "Prelude" "Gets the first solution via a depth-first strategy.\n" False UnknownFR),(FunctionInfo "best" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (FuncType (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Bool") []))) (TCons ("Prelude","[]") [(FuncType (TVar 0) (TCons ("Prelude","Success") []))]))) "Prelude" "Gets the best solution via a depth-first strategy according to\na specified operator that can always take a decision which\nof two solutions is better.\nIn general, the comparison operation should be rigid in its arguments!\n" False UnknownFR),(FunctionInfo "findall" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TCons ("Prelude","[]") [(TVar 0)])) "Prelude" "Gets all solutions via a depth-first strategy and unpack\nthe values from the lambda-abstractions.\nSimilar to Prolog's findall.\n" False UnknownFR),(FunctionInfo "findfirst" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TVar 0)) "Prelude" "Gets the first solution via a depth-first strategy\nand unpack the values from the search goals.\n" False UnknownFR),(FunctionInfo "browse" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Shows the solution of a solved constraint.\n" False UnknownFR),(FunctionInfo "browseList" (FuncType (TCons ("Prelude","[]") [(FuncType (TVar 0) (TCons ("Prelude","Success") []))]) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])])) "Prelude" "Unpacks solutions from a list of lambda abstractions and write \nthem to the screen.\n" False KnownFlex),(FunctionInfo "unpack" (FuncType (FuncType (TVar 0) (TCons ("Prelude","Success") [])) (TVar 0)) "Prelude" "Unpacks a solution's value from a (solved) search goal.\n" False UnknownFR),(FunctionInfo "PEVAL" (FuncType (TVar 0) (TVar 0)) "Prelude" "Identity function used by the partial evaluator\nto mark expressions to be partially evaluated.\n" False UnknownFR),(FunctionInfo "normalForm" (FuncType (TVar 0) (TVar 0)) "Prelude" "Evaluates the argument to normal form and returns it.\n" False UnknownFR),(FunctionInfo "groundNormalForm" (FuncType (TVar 0) (TVar 0)) "Prelude" "Evaluates the argument to ground normal form and returns it.\nSuspends as long as the normal form of the argument is not ground.\n" False KnownRigid),(FunctionInfo "apply" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TVar 0) (TVar 1))) "Prelude" [] False UnknownFR),(FunctionInfo "cond" (FuncType (TCons ("Prelude","Success") []) (FuncType (TVar 0) (TVar 0))) "Prelude" [] False UnknownFR),(FunctionInfo "letrec" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Success") []))) "Prelude" [] False UnknownFR),(FunctionInfo "=:<=" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Success") []))) "Prelude" "Non-strict equational constraint. Experimental.\n" False UnknownFR),(FunctionInfo "=:<<=" (FuncType (TVar 0) (FuncType (TVar 0) (TCons ("Prelude","Success") []))) "Prelude" "Non-strict equational constraint for linear function patterns.\nThus, it must be ensured that the first argument is always (after evalutation\nby narrowing) a linear pattern. Experimental.\n" False UnknownFR),(FunctionInfo "ifVar" (FuncType (TVar 0) (FuncType (TVar 1) (FuncType (TVar 1) (TVar 1)))) "Prelude" "internal function to implement =:<=\n" False UnknownFR),(FunctionInfo "failure" (FuncType (TVar 0) (FuncType (TVar 1) (TVar 2))) "Prelude" "internal operation to implement failure reporting\n" False UnknownFR)] [(TypeInfo "()" [(("Prelude","()"),[])] [] "Prelude" []),(TypeInfo "[]" [(("Prelude","[]"),[]),(("Prelude",":"),[(TVar 0),(TCons ("Prelude","[]") [(TVar 0)])])] [0] "Prelude" []),(TypeInfo "(,)" [(("Prelude","(,)"),[(TVar 0),(TVar 1)])] [0,1] "Prelude" []),(TypeInfo "(,,)" [(("Prelude","(,,)"),[(TVar 0),(TVar 1),(TVar 2)])] [0,1,2] "Prelude" []),(TypeInfo "(,,,)" [(("Prelude","(,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3)])] [0,1,2,3] "Prelude" []),(TypeInfo "(,,,,)" [(("Prelude","(,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4)])] [0,1,2,3,4] "Prelude" []),(TypeInfo "(,,,,,)" [(("Prelude","(,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5)])] [0,1,2,3,4,5] "Prelude" []),(TypeInfo "(,,,,,,)" [(("Prelude","(,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6)])] [0,1,2,3,4,5,6] "Prelude" []),(TypeInfo "(,,,,,,,)" [(("Prelude","(,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7)])] [0,1,2,3,4,5,6,7] "Prelude" []),(TypeInfo "(,,,,,,,,)" [(("Prelude","(,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8)])] [0,1,2,3,4,5,6,7,8] "Prelude" []),(TypeInfo "(,,,,,,,,,)" [(("Prelude","(,,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8),(TVar 9)])] [0,1,2,3,4,5,6,7,8,9] "Prelude" []),(TypeInfo "(,,,,,,,,,,)" [(("Prelude","(,,,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8),(TVar 9),(TVar 10)])] [0,1,2,3,4,5,6,7,8,9,10] "Prelude" []),(TypeInfo "(,,,,,,,,,,,)" [(("Prelude","(,,,,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8),(TVar 9),(TVar 10),(TVar 11)])] [0,1,2,3,4,5,6,7,8,9,10,11] "Prelude" []),(TypeInfo "(,,,,,,,,,,,,)" [(("Prelude","(,,,,,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8),(TVar 9),(TVar 10),(TVar 11),(TVar 12)])] [0,1,2,3,4,5,6,7,8,9,10,11,12] "Prelude" []),(TypeInfo "(,,,,,,,,,,,,,)" [(("Prelude","(,,,,,,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8),(TVar 9),(TVar 10),(TVar 11),(TVar 12),(TVar 13)])] [0,1,2,3,4,5,6,7,8,9,10,11,12,13] "Prelude" []),(TypeInfo "(,,,,,,,,,,,,,,)" [(("Prelude","(,,,,,,,,,,,,,,)"),[(TVar 0),(TVar 1),(TVar 2),(TVar 3),(TVar 4),(TVar 5),(TVar 6),(TVar 7),(TVar 8),(TVar 9),(TVar 10),(TVar 11),(TVar 12),(TVar 13),(TVar 14)])] [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] "Prelude" []),(TypeInfo "String" [(("Prelude","String"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "Prelude" []),(TypeInfo "Int" [] [] "Prelude" []),(TypeInfo "Float" [] [] "Prelude" []),(TypeInfo "Char" [] [] "Prelude" []),(TypeInfo "Bool" [(("Prelude","False"),[]),(("Prelude","True"),[])] [] "Prelude" []),(TypeInfo "Ordering" [(("Prelude","LT"),[]),(("Prelude","EQ"),[]),(("Prelude","GT"),[])] [] "Prelude" "Ordering type. Useful as a result of comparison functions.\n"),(TypeInfo "Success" [] [] "Prelude" []),(TypeInfo "Maybe" [(("Prelude","Nothing"),[]),(("Prelude","Just"),[(TVar 0)])] [0] "Prelude" []),(TypeInfo "Either" [(("Prelude","Left"),[(TVar 0)]),(("Prelude","Right"),[(TVar 1)])] [0,1] "Prelude" []),(TypeInfo "IO" [] [0] "Prelude" []),(TypeInfo "IOError" [(("Prelude","IOError"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "Prelude" "The (abstract) type of error values.\nCurrently, it contains only an error message as a string,\nbut it might be extended in the future to distinguish\nvarious error situations.\n")])