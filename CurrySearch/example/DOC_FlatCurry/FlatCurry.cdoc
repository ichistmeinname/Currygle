(CurryInfo (ModuleInfo "FlatCurry" "Michael Hanus" "Library to support meta-programming in Curry.\n\nThis library contains a definition for representing FlatCurry programs\nin Curry (type \"Prog\") and an I/O action to read Curry programs and\ntransform them into this representation (function \"readFlatCurry\").\n\n") [(FunctionInfo "readFlatCurry" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("FlatCurry","Prog") [])])) "FlatCurry" "I/O action which parses a Curry program and returns the corresponding\nFlatCurry program.\nThus, the argument is the file name without suffix \".curry\"\n(or \".lcurry\") and the result is a FlatCurry term representing this\nprogram.\n" False UnknownFR),(FunctionInfo "readFlatCurryWithParseOptions" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Distribution","FrontendParams") []) (TCons ("Prelude","IO") [(TCons ("FlatCurry","Prog") [])]))) "FlatCurry" "I/O action which reads a FlatCurry program from a file\nwith respect to some parser options.\nThis I/O action is used by the standard action `readFlatCurry`.\nIt is currently predefined only in Curry2Prolog.\n" False UnknownFR),(FunctionInfo "flatCurryFileName" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "FlatCurry" "Transforms a name of a Curry program (with or without suffix \".curry\"\nor \".lcurry\") into the name of the file containing the\ncorresponding FlatCurry program.\n" False UnknownFR),(FunctionInfo "flatCurryIntName" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "FlatCurry" "Transforms a name of a Curry program (with or without suffix \".curry\"\nor \".lcurry\") into the name of the file containing the\ncorresponding FlatCurry program.\n" False UnknownFR),(FunctionInfo "readFlatCurryFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("FlatCurry","Prog") [])])) "FlatCurry" "I/O action which reads a FlatCurry program from a file in \".fcy\" format.\nIn contrast to `readFlatCurry`, this action does not parse\na source program. Thus, the argument must be the name of an existing\nfile (with suffix \".fcy\") containing a FlatCurry program in \".fcy\"\nformat and the result is a FlatCurry term representing this program.\n" False UnknownFR),(FunctionInfo "readFlatCurryInt" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("FlatCurry","Prog") [])])) "FlatCurry" "I/O action which returns the interface of a Curry program, i.e.,\na FlatCurry program containing only \"Public\" entities and function\ndefinitions without rules (i.e., external functions).\nThe argument is the file name without suffix \".curry\"\n(or \".lcurry\") and the result is a FlatCurry term representing the\ninterface of this program.\n" False UnknownFR),(FunctionInfo "writeFCY" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("FlatCurry","Prog") []) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "FlatCurry" "Writes a FlatCurry program into a file in \".fcy\" format.\nThe first argument must be the name of the target file\n(with suffix \".fcy\").\n" False UnknownFR),(FunctionInfo "showQNameInModule" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]))) "FlatCurry" "Translates a given qualified type name into external name relative to\na module. Thus, names not defined in this module (except for names\ndefined in the prelude) are prefixed with their module name.\n" False ConflictFR)] [(TypeInfo "QName" [(("FlatCurry","QName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "FlatCurry" "The data type for representing qualified names.\nIn FlatCurry all names are qualified to avoid name clashes.\nThe first component is the module name and the second component the\nunqualified name as it occurs in the source program.\n" True),(TypeInfo "TVarIndex" [(("FlatCurry","TVarIndex"),[(TCons ("Prelude","Int") [])])] [] "FlatCurry" "The data type for representing type variables.\nThey are represented by `(TVar i)` where `i` is a type variable index.\n" True),(TypeInfo "VarIndex" [(("FlatCurry","VarIndex"),[(TCons ("Prelude","Int") [])])] [] "FlatCurry" "Data type for representing object variables.\nObject variables occurring in expressions are represented by `(Var i)`\nwhere `i` is a variable index.\n" True),(TypeInfo "Prog" [(("FlatCurry","Prog"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("FlatCurry","TypeDecl") [])]),(TCons ("Prelude","[]") [(TCons ("FlatCurry","FuncDecl") [])]),(TCons ("Prelude","[]") [(TCons ("FlatCurry","OpDecl") [])])])] [] "FlatCurry" "Data type for representing a Curry module in the intermediate form.\nA value of this data type has the form\n\n    (Prog modname imports typedecls functions opdecls translation_table)\n\nwhere\n`modname` is the name of this module,\n`imports` is the list of modules names that are imported,\n`typedecls`, `opdecls`, `functions`, translation of type names\nand constructor/function names are explained see below\n" False),(TypeInfo "Visibility" [(("FlatCurry","Public"),[]),(("FlatCurry","Private"),[])] [] "FlatCurry" "Data type to specify the visibility of various entities.\n" False),(TypeInfo "TypeDecl" [(("FlatCurry","Type"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("FlatCurry","Visibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Prelude","[]") [(TCons ("FlatCurry","ConsDecl") [])])]),(("FlatCurry","TypeSyn"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("FlatCurry","Visibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("FlatCurry","TypeExpr") [])])] [] "FlatCurry" "Data type for representing definitions of algebraic data types.\n\nA data type definition of the form\n\n    data t x1...xn = ...| c t1....tkc |...\n\nis represented by the FlatCurry term\n\n    (Type t [i1,...,in] [...(Cons c kc [t1,...,tkc])...])\n\nwhere each `ij` is the index of the type variable `xj`.\n\nNote: the type variable indices are unique inside each type declaration\n      and are usually numbered from 0\n\nThus, a data type declaration consists of the name of the data type,\na list of type parameters and a list of constructor declarations.\n" False),(TypeInfo "ConsDecl" [(("FlatCurry","Cons"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("FlatCurry","Visibility") []),(TCons ("Prelude","[]") [(TCons ("FlatCurry","TypeExpr") [])])])] [] "FlatCurry" "A constructor declaration consists of the name and arity of the\nconstructor and a list of the argument types of the constructor.\n" False),(TypeInfo "TypeExpr" [(("FlatCurry","TVar"),[(TCons ("Prelude","Int") [])]),(("FlatCurry","FuncType"),[(TCons ("FlatCurry","TypeExpr") []),(TCons ("FlatCurry","TypeExpr") [])]),(("FlatCurry","TCons"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("FlatCurry","TypeExpr") [])])])] [] "FlatCurry" "Data type for type expressions.\nA type expression is either a type variable, a function type,\nor a type constructor application.\n\nNote: the names of the predefined type constructors are\n\"Int\", \"Float\", \"Bool\", \"Char\", \"IO\", \"Success\",\n\"()\" (unit type), \"(,...,)\" (tuple types), \"[]\" (list type)\n" False),(TypeInfo "OpDecl" [(("FlatCurry","Op"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("FlatCurry","Fixity") []),(TCons ("Prelude","Int") [])])] [] "FlatCurry" "Data type for operator declarations.\nAn operator declaration `fix p n` in Curry corresponds to the\nFlatCurry term `(Op n fix p)`.\n" False),(TypeInfo "Fixity" [(("FlatCurry","InfixOp"),[]),(("FlatCurry","InfixlOp"),[]),(("FlatCurry","InfixrOp"),[])] [] "FlatCurry" "Data types for the different choices for the fixity of an operator.\n" False),(TypeInfo "FuncDecl" [(("FlatCurry","Func"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("FlatCurry","Visibility") []),(TCons ("FlatCurry","TypeExpr") []),(TCons ("FlatCurry","Rule") [])])] [] "FlatCurry" "Data type for representing function declarations.\n\nA function declaration in FlatCurry is a term of the form\n\n    (Func name k type (Rule [i1,...,ik] e))\n\nand represents the function `name` with definition\n\n    name :: type\n    name x1...xk = e\n\nwhere each `ij` is the index of the variable `xj`.\n\nNote: the variable indices are unique inside each function declaration\n      and are usually numbered from 0\n\nExternal functions are represented as\n\n    (Func name arity type (External s))\n\nwhere s is the external name associated to this function.\n\nThus, a function declaration consists of the name, arity, type, and rule.\n" False),(TypeInfo "Rule" [(("FlatCurry","Rule"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("FlatCurry","Expr") [])]),(("FlatCurry","External"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "FlatCurry" "A rule is either a list of formal parameters together with an expression\nor an \"External\" tag.\n" False),(TypeInfo "CaseType" [(("FlatCurry","Rigid"),[]),(("FlatCurry","Flex"),[])] [] "FlatCurry" "Data type for classifying case expressions.\nCase expressions can be either flexible or rigid in Curry.\n" False),(TypeInfo "CombType" [(("FlatCurry","FuncCall"),[]),(("FlatCurry","ConsCall"),[]),(("FlatCurry","FuncPartCall"),[(TCons ("Prelude","Int") [])]),(("FlatCurry","ConsPartCall"),[(TCons ("Prelude","Int") [])])] [] "FlatCurry" "Data type for classifying combinations\n(i.e., a function/constructor applied to some arguments).\n" False),(TypeInfo "Expr" [(("FlatCurry","Var"),[(TCons ("Prelude","Int") [])]),(("FlatCurry","Lit"),[(TCons ("FlatCurry","Literal") [])]),(("FlatCurry","Comb"),[(TCons ("FlatCurry","CombType") []),(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("FlatCurry","Expr") [])])]),(("FlatCurry","Let"),[(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("FlatCurry","Expr") [])])]),(TCons ("FlatCurry","Expr") [])]),(("FlatCurry","Free"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("FlatCurry","Expr") [])]),(("FlatCurry","Or"),[(TCons ("FlatCurry","Expr") []),(TCons ("FlatCurry","Expr") [])]),(("FlatCurry","Case"),[(TCons ("FlatCurry","CaseType") []),(TCons ("FlatCurry","Expr") []),(TCons ("Prelude","[]") [(TCons ("FlatCurry","BranchExpr") [])])])] [] "FlatCurry" "Data type for representing expressions.\n\nRemarks:\n\nif-then-else expressions are represented as function calls:\n\n    (if e1 then e2 else e3)\n\nis represented as\n\n    (Comb FuncCall (\"Prelude\",\"if_then_else\") [e1,e2,e3])\n\nHigher-order applications are represented as calls to the (external)\nfunction `apply`. For instance, the rule\n\n    app f x = f x\n\nis represented as\n\n    (Rule  [0,1] (Comb FuncCall (\"Prelude\",\"apply\") [Var 0, Var 1]))\n\nA conditional rule is represented as a call to an external function\n`cond` where the first argument is the condition (a constraint).\nFor instance, the rule\n\n    equal2 x | x=:=2 = success\n\nis represented as\n\n    (Rule [0]\n          (Comb FuncCall (\"Prelude\",\"cond\")\n                [Comb FuncCall (\"Prelude\",\"=:=\") [Var 0, Lit (Intc 2)],\n                 Comb FuncCall (\"Prelude\",\"success\") []]))\n\n" False),(TypeInfo "BranchExpr" [(("FlatCurry","Branch"),[(TCons ("FlatCurry","Pattern") []),(TCons ("FlatCurry","Expr") [])])] [] "FlatCurry" "Data type for representing branches in a case expression.\n\nBranches \"(m.c x1...xn) -> e\" in case expressions are represented as\n\n    (Branch (Pattern (m,c) [i1,...,in]) e)\n\nwhere each `ij` is the index of the pattern variable `xj`, or as\n\n    (Branch (LPattern (Intc i)) e)\n\nfor integers as branch patterns (similarly for other literals\nlike float or character constants).\n" False),(TypeInfo "Pattern" [(("FlatCurry","Pattern"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])]),(("FlatCurry","LPattern"),[(TCons ("FlatCurry","Literal") [])])] [] "FlatCurry" "Data type for representing patterns in case expressions.\n" False),(TypeInfo "Literal" [(("FlatCurry","Intc"),[(TCons ("Prelude","Int") [])]),(("FlatCurry","Floatc"),[(TCons ("Prelude","Float") [])]),(("FlatCurry","Charc"),[(TCons ("Prelude","Char") [])])] [] "FlatCurry" "Data type for representing literals occurring in an expression\nor case branch. It is either an integer, a float, or a character constant.\n" False)])