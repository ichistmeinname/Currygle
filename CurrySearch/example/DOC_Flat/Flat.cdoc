(CurryInfo (ModuleInfo "Flat" "Michael Hanus" "Library to support meta-programming in Curry.\n\nThis library contains a definition for representing FlatCurry programs\nin Curry (type \"Prog\") and an I/O action to read Curry programs and\ntransform them into this representation (function \"readFlatCurry\").\n\n") [(FunctionInfo "readFlatCurry" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Flat","Prog") [])])) "Flat" "I/O action which parses a Curry program and returns the corresponding\nFlatCurry program.\nThus, the argument is the file name without suffix \".curry\"\n(or \".lcurry\") and the result is a FlatCurry term representing this\nprogram.\n" False UnknownFR),(FunctionInfo "readFlatCurryWithParseOptions" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Distribution","FrontendParams") []) (TCons ("Prelude","IO") [(TCons ("Flat","Prog") [])]))) "Flat" "I/O action which reads a FlatCurry program from a file\nwith respect to some parser options.\nThis I/O action is used by the standard action <CODE>readFlatCurry</CODE>.\nIt is currently predefined only in Curry2Prolog.\n" False UnknownFR),(FunctionInfo "readFlatCurryFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Flat","Prog") [])])) "Flat" "I/O action which reads a FlatCurry program from a file in \".fcy\" format.\nIn contrast to <CODE>readFlatCurry</CODE>, this action does not parse\na source program. Thus, the argument must be the name of an existing\nfile (with suffix \".fcy\") containing a FlatCurry program in \".fcy\"\nformat and the result is a FlatCurry term representing this program.\nIt is currently predefined only in Curry2Prolog.\n" False UnknownFR),(FunctionInfo "prim_readFlatCurryFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("Flat","Prog") [])])) "Flat" [] False UnknownFR),(FunctionInfo "splitFlatModName" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])) "Flat" "Splits an internal name into a pair of module name and name in local\nmodule.\n" False KnownRigid)] [(TypeInfo "TVarIndex" [(("Flat","TVarIndex"),[(TCons ("Prelude","Int") [])])] [] "Flat" "The data type for representing type variables.\nThey are represented by (TVar i) where i is a type variable index.\n" True),(TypeInfo "VarIndex" [(("Flat","VarIndex"),[(TCons ("Prelude","Int") [])])] [] "Flat" "Data types for representing object variables.\nObject variables occurring in expressions are represented by (Var i)\nwhere i is a variable index.\n" True),(TypeInfo "Prog" [(("Flat","Prog"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("Flat","TypeDecl") [])]),(TCons ("Prelude","[]") [(TCons ("Flat","FuncDecl") [])]),(TCons ("Prelude","[]") [(TCons ("Flat","OpDecl") [])]),(TCons ("Prelude","[]") [(TCons ("Flat","Translation") [])])])] [] "Flat" "Data type for representing a Curry module in the intermediate form.\nA value of this data type has the form\n<CODE>\n (Prog modname imports typedecls functions opdecls translation_table)\n</CODE>\nwhere modname: name of this module,\n      imports: list of modules names that are imported,\n      typedecls, opdecls, functions, translation_table: see below\n" False),(TypeInfo "TypeDecl" [(("Flat","Type"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Prelude","[]") [(TCons ("Flat","ConsDecl") [])])])] [] "Flat" "Data type for representing definitions of algebraic data types.\n<PRE>\nA data type definition of the form\n\ndata t x1...xn = ...| c t1....tkc |...\n\nis represented by the FlatCurry term\n\n(Type t [i1,...,in] [...(Cons c kc [t1,...,tkc])...])\n\nwhere each ij is the index of the type variable xj\n\nNote: the type variable indices are unique inside each type declaration\n      and are usually numbered from 0\n\nThus, a data type declaration consists of the name of the data type,\na list of type parameters and a list of constructor declarations.\n</PRE>\n" False),(TypeInfo "ConsDecl" [(("Flat","Cons"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Flat","TypeExpr") [])])])] [] "Flat" "A constructor declaration consists of the name and arity of the\nconstructor and a list of the argument types of the constructor.\n" False),(TypeInfo "TypeExpr" [(("Flat","TVar"),[(TCons ("Prelude","Int") [])]),(("Flat","FuncType"),[(TCons ("Flat","TypeExpr") []),(TCons ("Flat","TypeExpr") [])]),(("Flat","TCons"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Flat","TypeExpr") [])])])] [] "Flat" "Data type for type expressions.\nA type expression is either a type variable, a function type,\nor a type constructor application.\n\nNote: the names of the predefined type constructors are\n      \"Int\", \"Float\", \"Bool\", \"Char\", \"IO\", \"Success\",\n      \"()\" (unit type), \"(,...,)\" (tuple types), \"[]\" (list type)\n" False),(TypeInfo "OpDecl" [(("Flat","Op"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Flat","Fixity") []),(TCons ("Prelude","Int") [])])] [] "Flat" "Data type for operator declarations.\nAn operator declaration \"fix p n\" in Curry corresponds to the\nFlatCurry term (Op n fix p).\n" False),(TypeInfo "Fixity" [(("Flat","InfixOp"),[]),(("Flat","InfixlOp"),[]),(("Flat","InfixrOp"),[])] [] "Flat" "Data types for the different choices for the fixity of an operator.\n" False),(TypeInfo "FuncDecl" [(("Flat","Func"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","Int") []),(TCons ("Flat","TypeExpr") []),(TCons ("Flat","Rule") [])])] [] "Flat" "Data type for representing function declarations.\n<PRE>\nA function declaration in FlatCurry is a term of the form\n\n (Func name arity type (Rule [i_1,...,i_arity] e))\n\nand represents the function \"name\" with definition\n\n  name :: type\n  name x_1...x_arity = e\n\nwhere each i_j is the index of the variable x_j\n\nNote: the variable indices are unique inside each function declaration\n      and are usually numbered from 0\n\nExternal functions are represented as (Func name arity type (External s))\nwhere s is the external name associated to this function.\n\nThus, a function declaration consists of the name, arity, type, and rule.\n</PRE>\n" False),(TypeInfo "Rule" [(("Flat","Rule"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Flat","Expr") [])]),(("Flat","External"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "Flat" "A rule is either a list of formal parameters together with an expression\nor an \"External\" tag.\n" False),(TypeInfo "CaseType" [(("Flat","Rigid"),[]),(("Flat","Flex"),[])] [] "Flat" "Data type for classifying case expressions.\nCase expressions can be either flexible or rigid in Curry.\n" False),(TypeInfo "CombType" [(("Flat","FuncCall"),[]),(("Flat","ConsCall"),[]),(("Flat","PartCall"),[])] [] "Flat" "Data type for classifying combinations\n(i.e., a function/constructor applied to some arguments).\n" False),(TypeInfo "Expr" [(("Flat","Var"),[(TCons ("Prelude","Int") [])]),(("Flat","Lit"),[(TCons ("Flat","Literal") [])]),(("Flat","Comb"),[(TCons ("Flat","CombType") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Flat","Expr") [])])]),(("Flat","Apply"),[(TCons ("Flat","Expr") []),(TCons ("Flat","Expr") [])]),(("Flat","Constr"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Flat","Expr") [])]),(("Flat","Or"),[(TCons ("Flat","Expr") []),(TCons ("Flat","Expr") [])]),(("Flat","Case"),[(TCons ("Flat","CaseType") []),(TCons ("Flat","Expr") []),(TCons ("Prelude","[]") [(TCons ("Flat","BranchExpr") [])])]),(("Flat","Let"),[(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Flat","Expr") [])])]),(TCons ("Flat","Expr") [])]),(("Flat","Choice"),[(TCons ("Flat","Expr") [])]),(("Flat","GuardedExpr"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Flat","Expr") []),(TCons ("Flat","Expr") [])])] [] "Flat" "Data types for representing expressions.\n" False),(TypeInfo "BranchExpr" [(("Flat","Branch"),[(TCons ("Flat","Pattern") []),(TCons ("Flat","Expr") [])])] [] "Flat" "Data types for representing branches in a case expressions.\n<PRE>\nBranches \"(c x1...xn) -> e\" in case expressions are represented as\n\n  (Branch (Pattern c [i1,...,in]) e)\n\nwhere each ij is the index of the pattern variable xj, or as\n\n  (Branch (LPattern (Intc i)) e)\n\nfor integers as branch patterns (similarly for other literals\nlike float or character constants).\n</PRE>\n" False),(TypeInfo "Pattern" [(("Flat","Pattern"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])]),(("Flat","LPattern"),[(TCons ("Flat","Literal") [])])] [] "Flat" "Data type for representing patterns in case expressions.\n" False),(TypeInfo "Literal" [(("Flat","Intc"),[(TCons ("Prelude","Int") [])]),(("Flat","Floatc"),[(TCons ("Prelude","Float") [])]),(("Flat","Charc"),[(TCons ("Prelude","Char") [])])] [] "Flat" "Data type for representing literals occurring in an expression\nor case branch. It is either an integer, a float, or a character constant.\n" False),(TypeInfo "Translation" [(("Flat","Trans"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "Flat" "Data type for translating external into internal names.\nEach module contains a translation table to translate the\nexternal names (visible to the user) into internal names (used in\nthe implementation). Usually, the internal names are prefixed by\nthe name of the module (except for the prelude). Thus, the translation\ntable is a list of elements of the form\n<CODE>(Trans name internal_name)</CODE>.\n" False)])