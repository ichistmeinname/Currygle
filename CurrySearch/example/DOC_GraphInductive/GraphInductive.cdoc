(CurryInfo (ModuleInfo "GraphInductive" "Bernd Brassel" "Library for inductive graphs (port of a Haskell library by Martin Erwig).\n\nIn this library, graphs are composed and decomposed in an inductive way.\n\nThe key idea is as follows: \n\nA graph is either <i>empty</i> or it consists of <i>node context</i> \nand a <i>graph g'</i> which \nare put together by a constructor `(:&amp;)`.\n\nThis constructor `(:&amp;)`, however, is not a constructor in \nthe sense of abstract \ndata type, but more basically a defined constructing funtion. \n\nA <i>context</i> is a node together withe the edges to and from this node\ninto the nodes in the graph g'.\n\nFor examples of how to use this library, cf. the module `GraphAlgorithms`.\n\n") [(FunctionInfo ":&" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]) (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]))) "GraphInductive" "(:&amp;) takes a node-context and a Graph and yields a new graph.\n\nThe according key idea is detailed at the beginning.\n\nnl is the type of the node labels and el the edge labels.\n\nNote that it is an error to induce a context for \na node already contained in the graph.\n" False ConflictFR),(FunctionInfo "matchAny" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])]),(TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)])])) "GraphInductive" "decompose a graph into the 'Context' for an arbitrarily-chosen 'Node'\nand the remaining 'Graph'.\n\nIn order to use graphs as abstract data structures, we also need means to\ndecompose a graph. This decompostion should work as much like pattern matching\nas possible. The normal matching is done by the function matchAny, which takes\na graph and yields a graph decompostion.\n\nAccording to the main idea, matchAny . (:&amp;) should be an identity.\n" False ConflictFR),(FunctionInfo "empty" (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) "GraphInductive" "An empty 'Graph'.\n" False UnknownFR),(FunctionInfo "mkGraph" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 1)])]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Create a 'Graph' from the list of 'LNode's and 'LEdge's.\n" False UnknownFR),(FunctionInfo "buildGr" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])])]) (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)])) "GraphInductive" "Build a 'Graph' from a list of 'Context's.\n" False UnknownFR),(FunctionInfo "mkUGraph" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]) (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") [])])]) (TCons ("GraphInductive","Graph") [(TCons ("Prelude","()") []),(TCons ("Prelude","()") [])]))) "GraphInductive" "Build a quasi-unlabeled 'Graph' from the list of 'Node's and 'Edge's.\n" False UnknownFR),(FunctionInfo "insNode" (FuncType (TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Insert a 'LNode' into the 'Graph'.\n" False KnownFlex),(FunctionInfo "insEdge" (FuncType (TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 0)]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]) (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]))) "GraphInductive" "Insert a 'LEdge' into the 'Graph'.\n" False KnownFlex),(FunctionInfo "delNode" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Remove a 'Node' from the 'Graph'.\n" False UnknownFR),(FunctionInfo "delEdge" (FuncType (TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") [])]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Remove an 'Edge' from the 'Graph'.\n" False ConflictFR),(FunctionInfo "insNodes" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Insert multiple 'LNode's into the 'Graph'.\n" False UnknownFR),(FunctionInfo "insEdges" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 0)])]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]) (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]))) "GraphInductive" "Insert multiple 'LEdge's into the 'Graph'.\n" False UnknownFR),(FunctionInfo "delNodes" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Remove multiple 'Node's from the 'Graph'.\n" False KnownFlex),(FunctionInfo "delEdges" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") [])])]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]))) "GraphInductive" "Remove multiple 'Edge's from the 'Graph'.\n" False UnknownFR),(FunctionInfo "isEmpty" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","Bool") [])) "GraphInductive" "test if the given 'Graph' is empty.\n" False KnownFlex),(FunctionInfo "match" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","Maybe") [(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])])]),(TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)])]))) "GraphInductive" "match is the complement side of (:&amp;), decomposing a 'Graph' into the \n'MContext' found for the given node and the remaining 'Graph'.\n" False KnownFlex),(FunctionInfo "noNodes" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","Int") [])) "GraphInductive" "The number of 'Node's in a 'Graph'.\n" False KnownFlex),(FunctionInfo "nodeRange" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") [])])) "GraphInductive" "The minimum and maximum 'Node' in a 'Graph'.\n" False ConflictFR),(FunctionInfo "context" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])]))) "GraphInductive" "Find the context for the given 'Node'.  In contrast to \"match\",\n\"context\" causes an error if the 'Node' is\nnot present in the 'Graph'.\n" False KnownRigid),(FunctionInfo "lab" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Maybe") [(TVar 0)]))) "GraphInductive" "Find the label for a 'Node'.\n" False UnknownFR),(FunctionInfo "neighbors" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "GraphInductive" "Find the neighbors for a 'Node'.\n" False UnknownFR),(FunctionInfo "suc" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "GraphInductive" "Find all 'Node's that have a link from the given 'Node'.\n" False UnknownFR),(FunctionInfo "pre" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "GraphInductive" "Find all 'Node's that link to to the given 'Node'.\n" False UnknownFR),(FunctionInfo "lsuc" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 1)])]))) "GraphInductive" "Find all Nodes and their labels, which are linked from the given 'Node'.\n" False UnknownFR),(FunctionInfo "lpre" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 1)])]))) "GraphInductive" "Find all 'Node's that link to the given 'Node' and the label of each link.\n" False UnknownFR),(FunctionInfo "out" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 1)])]))) "GraphInductive" "Find all outward-bound 'LEdge's for the given 'Node'.\n" False UnknownFR),(FunctionInfo "inn" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 1)])]))) "GraphInductive" "Find all inward-bound 'LEdge's for the given 'Node'.\n" False UnknownFR),(FunctionInfo "outdeg" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "GraphInductive" "The outward-bound degree of the 'Node'.\n" False UnknownFR),(FunctionInfo "indeg" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "GraphInductive" "The inward-bound degree of the 'Node'.\n" False UnknownFR),(FunctionInfo "deg" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("Prelude","Int") []) (TCons ("Prelude","Int") []))) "GraphInductive" "The degree of the 'Node'.\n" False UnknownFR),(FunctionInfo "gelem" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","Bool") []))) "GraphInductive" "'True' if the 'Node' is present in the 'Graph'.\n" False UnknownFR),(FunctionInfo "equal" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","Bool") []))) "GraphInductive" "graph equality\n" False UnknownFR),(FunctionInfo "node'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","Int") [])) "GraphInductive" "The 'Node' in a 'Context'.\n" False KnownFlex),(FunctionInfo "lab'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TVar 1)) "GraphInductive" "The label in a 'Context'.\n" False KnownFlex),(FunctionInfo "labNode'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 1)])) "GraphInductive" "The 'LNode' from a 'Context'.\n" False KnownFlex),(FunctionInfo "neighbors'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])) "GraphInductive" "All 'Node's linked to or from in a 'Context'.\n" False KnownFlex),(FunctionInfo "suc'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])) "GraphInductive" "All 'Node's linked to in a 'Context'.\n" False KnownFlex),(FunctionInfo "pre'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])) "GraphInductive" "All 'Node's linked from in a 'Context'.\n" False KnownFlex),(FunctionInfo "lpre'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])])) "GraphInductive" "All 'Node's linked from in a 'Context', and the label of the links.\n" False KnownFlex),(FunctionInfo "lsuc'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])])) "GraphInductive" "All 'Node's linked from in a 'Context', and the label of the links.\n" False KnownFlex),(FunctionInfo "out'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 0)])])) "GraphInductive" "All outward-directed 'LEdge's in a 'Context'.\n" False KnownFlex),(FunctionInfo "inn'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 0)])])) "GraphInductive" "All inward-directed 'LEdge's in a 'Context'.\n" False KnownFlex),(FunctionInfo "outdeg'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","Int") [])) "GraphInductive" "The outward degree of a 'Context'.\n" False KnownFlex),(FunctionInfo "indeg'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","Int") [])) "GraphInductive" "The inward degree of a 'Context'.\n" False KnownFlex),(FunctionInfo "deg'" (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","Int") [])) "GraphInductive" "The degree of a 'Context'.\n" False KnownFlex),(FunctionInfo "labNodes" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])])) "GraphInductive" "A list of all 'LNode's in the 'Graph'.\n" False KnownFlex),(FunctionInfo "labEdges" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 1)])])) "GraphInductive" "A list of all 'LEdge's in the 'Graph'.\n" False KnownFlex),(FunctionInfo "nodes" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])) "GraphInductive" "List all 'Node's in the 'Graph'.\n" False UnknownFR),(FunctionInfo "edges" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") [])])])) "GraphInductive" "List all 'Edge's in the 'Graph'.\n" False UnknownFR),(FunctionInfo "newNodes" (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]))) "GraphInductive" "List N available 'Node's, ie 'Node's that are not used in the 'Graph'.\n" False UnknownFR),(FunctionInfo "ufold" (FuncType (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (FuncType (TVar 2) (TVar 2))) (FuncType (TVar 2) (FuncType (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]) (TVar 2)))) "GraphInductive" "Fold a function over the graph.\n" False KnownRigid),(FunctionInfo "gmap" (FuncType (FuncType (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 1),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","Int") [])])])]) (TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 2),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 3),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 2),(TCons ("Prelude","Int") [])])])])) (FuncType (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 0)]) (TCons ("GraphInductive","Graph") [(TVar 3),(TVar 2)]))) "GraphInductive" "Map a function over the graph.\n" False UnknownFR),(FunctionInfo "nmap" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 2)]) (TCons ("GraphInductive","Graph") [(TVar 1),(TVar 2)]))) "GraphInductive" "Map a function over the 'Node' labels in a graph.\n" False UnknownFR),(FunctionInfo "emap" (FuncType (FuncType (TVar 0) (TVar 1)) (FuncType (TCons ("GraphInductive","Graph") [(TVar 2),(TVar 0)]) (TCons ("GraphInductive","Graph") [(TVar 2),(TVar 1)]))) "GraphInductive" "Map a function over the 'Edge' labels in a graph.\n" False UnknownFR),(FunctionInfo "labUEdges" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TVar 1)])]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,,)") [(TVar 0),(TVar 1),(TCons ("Prelude","()") [])])])) "GraphInductive" "add label () to list of edges (node,node)\n" False UnknownFR),(FunctionInfo "labUNodes" (FuncType (TCons ("Prelude","[]") [(TVar 0)]) (TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 0),(TCons ("Prelude","()") [])])])) "GraphInductive" "add label () to list of nodes\n" False UnknownFR),(FunctionInfo "showGraph" (FuncType (TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "GraphInductive" "Represent Graph as String\n" False KnownFlex)] [(TypeInfo "Node" [(("GraphInductive","Node"),[(TCons ("Prelude","Int") [])])] [] "GraphInductive" "Nodes and edges themselves (in contrast to their labels) are coded as integers.\n\nFor both of them, there are variants as labeled, unlabelwd and quasi unlabeled \n(labeled with ()).\n\n\nUnlabeled node\n" True),(TypeInfo "LNode" [(("GraphInductive","LNode"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])])] [0] "GraphInductive" "Labeled node\n" True),(TypeInfo "UNode" [(("GraphInductive","UNode"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","()") [])])])] [] "GraphInductive" "Quasi-unlabeled node\n" True),(TypeInfo "Edge" [(("GraphInductive","Edge"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") [])])])] [] "GraphInductive" "Unlabeled edge\n" True),(TypeInfo "LEdge" [(("GraphInductive","LEdge"),[(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TVar 0)])])] [0] "GraphInductive" "Labeled edge\n" True),(TypeInfo "UEdge" [(("GraphInductive","UEdge"),[(TCons ("Prelude","(,,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","Int") []),(TCons ("Prelude","()") [])])])] [] "GraphInductive" "Quasi-unlabeled edge\n" True),(TypeInfo "Context" [(("GraphInductive","Context"),[(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])])])] [0,1] "GraphInductive" "The context of a node is the node itself (along with label) and its adjacent nodes.\nThus, a context is a quadrupel, for node n it is of the form\n(edges to n,node n,n's label,edges from n)\n" True),(TypeInfo "MContext" [(("GraphInductive","MContext"),[(TCons ("Prelude","Maybe") [(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])])])])] [0,1] "GraphInductive" "maybe context\n" True),(TypeInfo "Context'" [(("GraphInductive","Context'"),[(TCons ("Prelude","(,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])])])] [0,1] "GraphInductive" "context with edges and node label only, without the node identifier itself\n" True),(TypeInfo "UContext" [(("GraphInductive","UContext"),[(TCons ("Prelude","(,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])])])] [] "GraphInductive" "Unlabeled context.\n" True),(TypeInfo "GDecomp" [(("GraphInductive","GDecomp"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])]),(TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)])])])] [0,1] "GraphInductive" "A graph decompostion is a context for a node n and the remaining graph without\nthat node.\n" True),(TypeInfo "Decomp" [(("GraphInductive","Decomp"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Maybe") [(TCons ("Prelude","(,,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])]),(TCons ("Prelude","Int") []),(TVar 0),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TVar 1),(TCons ("Prelude","Int") [])])])])]),(TCons ("GraphInductive","Graph") [(TVar 0),(TVar 1)])])])] [0,1] "GraphInductive" "a decomposition with a maybe context \n" True),(TypeInfo "UDecomp" [(("GraphInductive","UDecomp"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Maybe") [(TCons ("Prelude","(,,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])])]),(TVar 0)])])] [0] "GraphInductive" "Unlabeled decomposition.\n" True),(TypeInfo "Path" [(("GraphInductive","Path"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])])])] [] "GraphInductive" "Unlabeled path\n" True),(TypeInfo "LPath" [(("GraphInductive","LPath"),[(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TVar 0)])])])] [0] "GraphInductive" "Labeled path\n" True),(TypeInfo "UPath" [(("GraphInductive","UPath"),[(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","()") [])])])])] [] "GraphInductive" "Quasi-unlabeled path\n" True),(TypeInfo "UGr" [(("GraphInductive","UGr"),[(TCons ("GraphInductive","Graph") [(TCons ("Prelude","()") []),(TCons ("Prelude","()") [])])])] [] "GraphInductive" "a graph without any labels\n" True),(TypeInfo "Graph" [] [0,1] "GraphInductive" "The type variables of Graph are <i>nodeLabel</i> and <i>edgeLabel</i>.\nThe internal representation of Graph is hidden.\n" False)])