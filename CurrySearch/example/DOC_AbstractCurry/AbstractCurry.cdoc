(CurryInfo (ModuleInfo "AbstractCurry" "Michael Hanus" "Library to support meta-programming in Curry.\n\nThis library contains a definition for representing Curry programs\nin Curry (type \"CurryProg\") and an I/O action to read Curry programs and\ntransform them into this abstract representation (function \"readCurry\").\n\nNote this defines a slightly new format for AbstractCurry\nin comparison to the first proposal of 2003.\n\nAssumption: an abstract Curry program is stored in file with extension .acy\n\n") [(FunctionInfo "readCurry" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("AbstractCurry","CurryProg") [])])) "AbstractCurry" "I/O action which parses a Curry program and returns the corresponding\ntyped Abstract Curry program.\nThus, the argument is the file name without suffix \".curry\"\nor \".lcurry\") and the result is a Curry term representing this\nprogram.\n" False UnknownFR),(FunctionInfo "readUntypedCurry" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("AbstractCurry","CurryProg") [])])) "AbstractCurry" "I/O action which parses a Curry program and returns the corresponding\nuntyped Abstract Curry program.\nThus, the argument is the file name without suffix \".curry\"\nor \".lcurry\") and the result is a Curry term representing this\nprogram.\n" False UnknownFR),(FunctionInfo "readCurryWithParseOptions" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Distribution","FrontendParams") []) (TCons ("Prelude","IO") [(TCons ("AbstractCurry","CurryProg") [])]))) "AbstractCurry" "I/O action which reads a typed Curry program from a file (with extension\n\".acy\") with respect to some parser options.\nThis I/O action is used by the standard action <CODE>readCurry</CODE>.\nIt is currently predefined only in Curry2Prolog.\n" False UnknownFR),(FunctionInfo "readUntypedCurryWithParseOptions" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("Distribution","FrontendParams") []) (TCons ("Prelude","IO") [(TCons ("AbstractCurry","CurryProg") [])]))) "AbstractCurry" "I/O action which reads an untyped Curry program from a file (with extension\n\".uacy\") with respect to some parser options. For more details\nsee function 'readCurryWithParseOptions'\n" False UnknownFR),(FunctionInfo "abstractCurryFileName" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "AbstractCurry" "Transforms a name of a Curry program (with or without suffix \".curry\"\nor \".lcurry\") into the name of the file containing the\ncorresponding AbstractCurry program.\n" False UnknownFR),(FunctionInfo "untypedAbstractCurryFileName" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])) "AbstractCurry" "Transforms a name of a Curry program (with or without suffix \".curry\"\nor \".lcurry\") into the name of the file containing the\ncorresponding untyped AbstractCurry program.\n" False UnknownFR),(FunctionInfo "readAbstractCurryFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (TCons ("Prelude","IO") [(TCons ("AbstractCurry","CurryProg") [])])) "AbstractCurry" "I/O action which reads an AbstractCurry program from a file in \".acy\"\nformat. In contrast to <CODE>readCurry</CODE>, this action does not parse\na source program. Thus, the argument must be the name of an existing\nfile (with suffix \".acy\") containing an AbstractCurry program in \".acy\"\nformat and the result is a Curry term representing this program.\nIt is currently predefined only in Curry2Prolog.\n" False UnknownFR),(FunctionInfo "writeAbstractCurryFile" (FuncType (TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]) (FuncType (TCons ("AbstractCurry","CurryProg") []) (TCons ("Prelude","IO") [(TCons ("Prelude","()") [])]))) "AbstractCurry" "Writes an AbstractCurry program into a file in \".acy\" format.\nThe first argument must be the name of the target file\n(with suffix \".acy\").\n" False UnknownFR)] [(TypeInfo "QName" [(("AbstractCurry","QName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry" "The data type for representing qualified names.\nIn AbstractCurry all names are qualified to avoid name clashes.\nThe first component is the module name and the second component the\nunqualified name as it occurs in the source program.\n" True),(TypeInfo "CTVarIName" [(("AbstractCurry","CTVarIName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry" "The data type for representing type variables.\nThey are represented by (i,n) where i is a type variable index\nwhich is unique inside a function and n is a name (if possible,\nthe name written in the source program).\n" True),(TypeInfo "CVarIName" [(("AbstractCurry","CVarIName"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry" "Data types for representing object variables.\nObject variables occurring in expressions are represented by (Var i)\nwhere i is a variable index.\n" True),(TypeInfo "CurryProg" [(("AbstractCurry","CurryProg"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CTypeDecl") [])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CFuncDecl") [])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","COpDecl") [])])])] [] "AbstractCurry" "Data type for representing a Curry module in the intermediate form.\nA value of this data type has the form\n<CODE>\n (CProg modname imports typedecls functions opdecls)\n</CODE>\nwhere modname: name of this module,\n      imports: list of modules names that are imported,\n      typedecls, opdecls, functions: see below\n" False),(TypeInfo "CVisibility" [(("AbstractCurry","Public"),[]),(("AbstractCurry","Private"),[])] [] "AbstractCurry" [] False),(TypeInfo "CTypeDecl" [(("AbstractCurry","CType"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CConsDecl") [])])]),(("AbstractCurry","CTypeSyn"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(TCons ("AbstractCurry","CTypeExpr") [])])] [] "AbstractCurry" "Data type for representing definitions of algebraic data types\nand type synonyms.\n\nA data type definition of the form\n\n<code>data t x1...xn = ...| c t1....tkc |...</code>\n\nis represented by the Curry term\n\n<code>(CType t v [i1,...,in] [...(CCons c kc v [t1,...,tkc])...])</code>\n\nwhere each <code>ij</code> is the index of the type variable\n<code> xj</code>.\n\nNote: the type variable indices are unique inside each type declaration\n      and are usually numbered from 0\n\nThus, a data type declaration consists of the name of the data type,\na list of type parameters and a list of constructor declarations.\n" False),(TypeInfo "CConsDecl" [(("AbstractCurry","CCons"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("AbstractCurry","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CTypeExpr") [])])])] [] "AbstractCurry" "A constructor declaration consists of the name and arity of the\nconstructor and a list of the argument types of the constructor.\n" False),(TypeInfo "CTypeExpr" [(("AbstractCurry","CTVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry","CFuncType"),[(TCons ("AbstractCurry","CTypeExpr") []),(TCons ("AbstractCurry","CTypeExpr") [])]),(("AbstractCurry","CTCons"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CTypeExpr") [])])])] [] "AbstractCurry" "Data type for type expressions.\nA type expression is either a type variable, a function type,\nor a type constructor application.\n\nNote: the names of the predefined type constructors are\n      \"Int\", \"Float\", \"Bool\", \"Char\", \"IO\", \"Success\",\n      \"()\" (unit type), \"(,...,)\" (tuple types), \"[]\" (list type)\n" False),(TypeInfo "COpDecl" [(("AbstractCurry","COp"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry","CFixity") []),(TCons ("Prelude","Int") [])])] [] "AbstractCurry" "Data type for operator declarations.\nAn operator declaration \"fix p n\" in Curry corresponds to the\nAbstractCurry term (COp n fix p).\n" False),(TypeInfo "CFixity" [(("AbstractCurry","CInfixOp"),[]),(("AbstractCurry","CInfixlOp"),[]),(("AbstractCurry","CInfixrOp"),[])] [] "AbstractCurry" [] False),(TypeInfo "CFuncDecl" [(("AbstractCurry","CFunc"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("AbstractCurry","CVisibility") []),(TCons ("AbstractCurry","CTypeExpr") []),(TCons ("AbstractCurry","CRules") [])]),(("AbstractCurry","CmtFunc"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","Int") []),(TCons ("AbstractCurry","CVisibility") []),(TCons ("AbstractCurry","CTypeExpr") []),(TCons ("AbstractCurry","CRules") [])])] [] "AbstractCurry" "Data type for representing function declarations.\n\nA function declaration in AbstractCurry is a term of the form\n\n<code>(CFunc name arity visibility type (CRules eval [CRule rule1,...,rulek]))</code>\n\nand represents the function <code>name</code> defined by the rules\n<code>rule1,...,rulek</code>.\n\nNote: the variable indices are unique inside each rule\n\nExternal functions are represented as\n<code>(CFunc name arity type (CExternal s))</code>\nwhere s is the external name associated to this function.\n\nThus, a function declaration consists of the name, arity, type, and\na list of rules.\n\nA function declaration with the constructor <code>CmtFunc</code>\nis similarly to <code>CFunc</code> but has a comment\nas an additional first argument. This comment could be used\nby pretty printers that generate a readable Curry program\ncontaining documentation comments.\n" False),(TypeInfo "CRules" [(("AbstractCurry","CRules"),[(TCons ("AbstractCurry","CEvalAnnot") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CRule") [])])]),(("AbstractCurry","CExternal"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "AbstractCurry" "A rule is either a list of formal parameters together with an expression\n(i.e., a rule in flat form), a list of general program rules with\nan evaluation annotation, or it is externally defined\n" False),(TypeInfo "CEvalAnnot" [(("AbstractCurry","CFlex"),[]),(("AbstractCurry","CRigid"),[]),(("AbstractCurry","CChoice"),[])] [] "AbstractCurry" "Data type for classifying evaluation annotations for functions.\nThey can be either flexible (default), rigid, or choice.\n" False),(TypeInfo "CRule" [(("AbstractCurry","CRule"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CPattern") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("AbstractCurry","CExpr") []),(TCons ("AbstractCurry","CExpr") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CLocalDecl") [])])])] [] "AbstractCurry" "The most general form of a rule. It consists of a list of patterns\n(left-hand side), a list of guards (\"success\" if not present in the\nsource text) with their corresponding right-hand sides, and\na list of local declarations.\n" False),(TypeInfo "CLocalDecl" [(("AbstractCurry","CLocalFunc"),[(TCons ("AbstractCurry","CFuncDecl") [])]),(("AbstractCurry","CLocalPat"),[(TCons ("AbstractCurry","CPattern") []),(TCons ("AbstractCurry","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CLocalDecl") [])])]),(("AbstractCurry","CLocalVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])])] [] "AbstractCurry" "Data type for representing local (let/where) declarations\n" False),(TypeInfo "CExpr" [(("AbstractCurry","CVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry","CLit"),[(TCons ("AbstractCurry","CLiteral") [])]),(("AbstractCurry","CSymbol"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry","CApply"),[(TCons ("AbstractCurry","CExpr") []),(TCons ("AbstractCurry","CExpr") [])]),(("AbstractCurry","CLambda"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CPattern") [])]),(TCons ("AbstractCurry","CExpr") [])]),(("AbstractCurry","CLetDecl"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CLocalDecl") [])]),(TCons ("AbstractCurry","CExpr") [])]),(("AbstractCurry","CDoExpr"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CStatement") [])])]),(("AbstractCurry","CListComp"),[(TCons ("AbstractCurry","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CStatement") [])])]),(("AbstractCurry","CCase"),[(TCons ("AbstractCurry","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CBranchExpr") [])])])] [] "AbstractCurry" "Data type for representing Curry expressions.\n" False),(TypeInfo "CStatement" [(("AbstractCurry","CSExpr"),[(TCons ("AbstractCurry","CExpr") [])]),(("AbstractCurry","CSPat"),[(TCons ("AbstractCurry","CPattern") []),(TCons ("AbstractCurry","CExpr") [])]),(("AbstractCurry","CSLet"),[(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CLocalDecl") [])])])] [] "AbstractCurry" "Data type for representing statements in do expressions and\nlist comprehensions.\n" False),(TypeInfo "CPattern" [(("AbstractCurry","CPVar"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])]),(("AbstractCurry","CPLit"),[(TCons ("AbstractCurry","CLiteral") [])]),(("AbstractCurry","CPComb"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CPattern") [])])]),(("AbstractCurry","CPAs"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","Int") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("AbstractCurry","CPattern") [])]),(("AbstractCurry","CPFuncComb"),[(TCons ("Prelude","(,)") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbstractCurry","CPattern") [])])])] [] "AbstractCurry" "Data type for representing pattern expressions.\n" False),(TypeInfo "CBranchExpr" [(("AbstractCurry","CBranch"),[(TCons ("AbstractCurry","CPattern") []),(TCons ("AbstractCurry","CExpr") [])])] [] "AbstractCurry" "Data type for representing branches in case expressions.\n" False),(TypeInfo "CLiteral" [(("AbstractCurry","CIntc"),[(TCons ("Prelude","Int") [])]),(("AbstractCurry","CFloatc"),[(TCons ("Prelude","Float") [])]),(("AbstractCurry","CCharc"),[(TCons ("Prelude","Char") [])])] [] "AbstractCurry" "Data type for representing literals occurring in an expression.\nIt is either an integer, a float, or a character constant.\n" False)])