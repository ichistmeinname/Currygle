(CurryInfo (ModuleInfo "AbsCurry" "Michael Hanus" "Library to support meta-programming in Curry.\n\nThis library contains a definition for representing Curry programs\nin Curry (type \"CProg\").\n\nNOTE: The I/O actions to read Curry programs and transform them\n      into this abstract representation can be found in the module\n      AbsCurryIO.\n\n") [] [(TypeInfo "CTVarIndex" [(("AbsCurry","CTVarIndex"),[(TCons ("Prelude","Int") [])])] [] "AbsCurry" "The data type for representing type variables.\nThey are represented by (CTVar i) where i is a type variable index.\n" True),(TypeInfo "CVarIndex" [(("AbsCurry","CVarIndex"),[(TCons ("Prelude","Int") [])])] [] "AbsCurry" "Data types for representing object variables.\nObject variables occurring in expressions are represented by (Var i)\nwhere i is a variable index.\n" True),(TypeInfo "CProg" [(("AbsCurry","CProg"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CTypeDecl") [])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CFuncDecl") [])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","COpDecl") [])])])] [] "AbsCurry" "Data type for representing a Curry module in the intermediate form.\nA value of this data type has the form\n<CODE>\n (CProg modname imports typedecls functions opdecls)\n</CODE>\nwhere modname: name of this module,\n      imports: list of modules names that are imported,\n      typedecls, opdecls, functions: see below\n" False),(TypeInfo "CVisibility" [(("AbsCurry","CExported"),[]),(("AbsCurry","CPrivate"),[])] [] "AbsCurry" [] False),(TypeInfo "CTypeDecl" [(("AbsCurry","CType"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("AbsCurry","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CConsDecl") [])])]),(("AbsCurry","CTypeSyn"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("AbsCurry","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("Prelude","Int") [])]),(TCons ("AbsCurry","CTypeExpr") [])])] [] "AbsCurry" "Data type for representing definitions of algebraic data types\nand type synonyms.\n<PRE>\nA data type definition of the form\n\ndata t x1...xn = ...| c t1....tkc |...\n\nis represented by the Curry term\n\n(CType t v [i1,...,in] [...(CCons c kc v [t1,...,tkc])...])\n\nwhere each ij is the index of the type variable xj\n\nNote: the type variable indices are unique inside each type declaration\n      and are usually numbered from 0\n\nThus, a data type declaration consists of the name of the data type,\na list of type parameters and a list of constructor declarations.\n</PRE>\n" False),(TypeInfo "CConsDecl" [(("AbsCurry","CCons"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","Int") []),(TCons ("AbsCurry","CVisibility") []),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CTypeExpr") [])])])] [] "AbsCurry" "A constructor declaration consists of the name and arity of the\nconstructor and a list of the argument types of the constructor.\n" False),(TypeInfo "CTypeExpr" [(("AbsCurry","CTVar"),[(TCons ("Prelude","Int") [])]),(("AbsCurry","CFuncType"),[(TCons ("AbsCurry","CTypeExpr") []),(TCons ("AbsCurry","CTypeExpr") [])]),(("AbsCurry","CTCons"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CTypeExpr") [])])])] [] "AbsCurry" "Data type for type expressions.\nA type expression is either a type variable, a function type,\nor a type constructor application.\n\nNote: the names of the predefined type constructors are\n      \"Int\", \"Float\", \"Bool\", \"Char\", \"IO\", \"Success\",\n      \"()\" (unit type), \"(,...,)\" (tuple types), \"[]\" (list type)\n" False),(TypeInfo "COpDecl" [(("AbsCurry","COp"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("AbsCurry","CFixity") []),(TCons ("Prelude","Int") [])])] [] "AbsCurry" "Data type for operator declarations.\nAn operator declaration \"fix p n\" in Curry corresponds to the\nAbstractCurry term (COp n fix p).\n" False),(TypeInfo "CFixity" [(("AbsCurry","CInfixOp"),[]),(("AbsCurry","CInfixlOp"),[]),(("AbsCurry","CInfixrOp"),[])] [] "AbsCurry" [] False),(TypeInfo "CFuncDecl" [(("AbsCurry","CFunc"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","Int") []),(TCons ("AbsCurry","CVisibility") []),(TCons ("AbsCurry","CTypeExpr") []),(TCons ("AbsCurry","CRules") [])])] [] "AbsCurry" "Data type for representing function declarations.\n<PRE>\nA function declaration in FlatCurry is a term of the form\n\n (CFunc name arity visibility type (CRules eval [CRule rule1,...,rulek]))\n\nand represents the function \"name\" with definition\n\n  name :: type\n  rule1\n  ...\n  rulek\n\nNote: the variable indices are unique inside each rule\n\nExternal functions are represented as (CFunc name arity type (CExternal s))\nwhere s is the external name associated to this function.\n\nThus, a function declaration consists of the name, arity, type, and\na list of rules.\n</PRE>\n" False),(TypeInfo "CRules" [(("AbsCurry","CRules"),[(TCons ("AbsCurry","CEvalAnnot") []),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CRule") [])])]),(("AbsCurry","CExternal"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])])] [] "AbsCurry" "A rule is either a list of formal parameters together with an expression\n(i.e., a rule in flat form), a list of general program rules with\nan evaluation annotation, or it is externally defined\n" False),(TypeInfo "CEvalAnnot" [(("AbsCurry","CFlex"),[]),(("AbsCurry","CRigid"),[]),(("AbsCurry","CChoice"),[])] [] "AbsCurry" "Data type for classifying evaluation annotations for functions.\nThey can be either flexible (default), rigid, or choice.\n" False),(TypeInfo "CRule" [(("AbsCurry","CRule"),[(TCons ("Prelude","[]") [(TCons ("AbsCurry","CPattern") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","(,)") [(TCons ("AbsCurry","CExpr") []),(TCons ("AbsCurry","CExpr") [])])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CLocalDecl") [])])])] [] "AbsCurry" "The most general form of a rule. It consists of a list of patterns\n(left-hand side), a list of guards (\"success\" if not present in the\nsource text) with their corresponding right-hand sides, and\na list of local declarations.\n" False),(TypeInfo "CLocalDecl" [(("AbsCurry","CLocalFunc"),[(TCons ("AbsCurry","CFuncDecl") [])]),(("AbsCurry","CLocalPat"),[(TCons ("AbsCurry","CTypeExpr") []),(TCons ("AbsCurry","CPattern") []),(TCons ("AbsCurry","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CLocalDecl") [])])]),(("AbsCurry","CLocalVar"),[(TCons ("AbsCurry","CTypeExpr") []),(TCons ("Prelude","Int") [])])] [] "AbsCurry" "Data type for representing local (let/where) declarations\n" False),(TypeInfo "CExpr" [(("AbsCurry","CVar"),[(TCons ("Prelude","Int") [])]),(("AbsCurry","CLit"),[(TCons ("AbsCurry","CLiteral") [])]),(("AbsCurry","CSymbol"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])])]),(("AbsCurry","CApply"),[(TCons ("AbsCurry","CExpr") []),(TCons ("AbsCurry","CExpr") [])]),(("AbsCurry","CLambda"),[(TCons ("Prelude","[]") [(TCons ("AbsCurry","CPattern") [])]),(TCons ("AbsCurry","CExpr") [])]),(("AbsCurry","CLetDecl"),[(TCons ("Prelude","[]") [(TCons ("AbsCurry","CLocalDecl") [])]),(TCons ("AbsCurry","CExpr") [])]),(("AbsCurry","CDoExpr"),[(TCons ("Prelude","[]") [(TCons ("AbsCurry","CStatement") [])])]),(("AbsCurry","CListComp"),[(TCons ("AbsCurry","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CStatement") [])])]),(("AbsCurry","CCase"),[(TCons ("AbsCurry","CExpr") []),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CBranchExpr") [])])])] [] "AbsCurry" "Data type for representing Curry expressions.\n" False),(TypeInfo "CStatement" [(("AbsCurry","CSExpr"),[(TCons ("AbsCurry","CExpr") [])]),(("AbsCurry","CSPat"),[(TCons ("AbsCurry","CPattern") []),(TCons ("AbsCurry","CExpr") [])]),(("AbsCurry","CSLet"),[(TCons ("Prelude","[]") [(TCons ("AbsCurry","CLocalDecl") [])])])] [] "AbsCurry" "Data type for representing statements in do expressions and\nlist comprehensions.\n" False),(TypeInfo "CPattern" [(("AbsCurry","CPVar"),[(TCons ("Prelude","Int") [])]),(("AbsCurry","CPLit"),[(TCons ("AbsCurry","CLiteral") [])]),(("AbsCurry","CPComb"),[(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("Prelude","Char") [])]),(TCons ("Prelude","[]") [(TCons ("AbsCurry","CPattern") [])])])] [] "AbsCurry" "Data type for representing pattern expressions.\n" False),(TypeInfo "CBranchExpr" [(("AbsCurry","CBranch"),[(TCons ("AbsCurry","CPattern") []),(TCons ("AbsCurry","CExpr") [])])] [] "AbsCurry" "Data type for representing branches in case expressions.\n" False),(TypeInfo "CLiteral" [(("AbsCurry","CIntc"),[(TCons ("Prelude","Int") [])]),(("AbsCurry","CFloatc"),[(TCons ("Prelude","Float") [])]),(("AbsCurry","CCharc"),[(TCons ("Prelude","Char") [])])] [] "AbsCurry" "Data type for representing literals occurring in an expression.\nIt is either an integer, a float, or a character constant.\n" False)])