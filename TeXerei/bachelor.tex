% Header mit Deklarationen
\documentclass[%
	pdftex,%              PDFTex verwenden
	a4paper,%             A4 Papier
	oneside,%             Einseitig
	chapterprefix,%       Kapitel anschreiben als Kapitel
	headsepline,%         Linie nach Kopfzeile
	%footsepline,%         Linie vor Fusszeile
	%pointlessnumbers,%     Nummern ohne abschließenden Punkt
	12pt%                 Grössere Schrift, besser lesbar am bildschrim
]{scrbook}
%
% Paket für Übersetzungen ins Deutsche
%
% \usepackage[french,ngerman]{babel}

\usepackage{todonotes}

%
% Pakete um Latin1 Zeichnensätze verwenden zu können und die dazu
% passenden Schriften.
%
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

%
% Paket für Quotes
%
% \usepackage[babel,french=guillemets,german=swiss]{csquotes}

%
% Paket zum Erweitern der Tabelleneigenschaften
%
\usepackage{array}

%
% Paket für schönere Tabellen
%
\usepackage{booktabs}

%
% Paket um Grafiken einbetten zu können
%
\usepackage{graphicx}

%
% Spezielle Schrift im Koma-Script setzen.
%
\usepackage{titlesec}
\newcommand*{\justifyheading}{\raggedleft}
\titleformat{\chapter}[display]
  {\normalfont\Huge\bfseries\justifyheading}{\thechapter}
  {10pt}{\Huge}
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}
% \setkomafont{sectioning}{\normalfont\bfseries}
\setkomafont{captionlabel}{\normalfont\bfseries} 
\setkomafont{pagehead}{\normalfont\bfseries} % Kopfzeilenschrift
\setkomafont{descriptionlabel}{\normalfont\bfseries}

%
% Zeilenumbruch bei Bildbeschreibungen.
%
\setcapindent{1em}

%
% Kopf und Fußzeilen
%
\usepackage{scrpage2}
\pagestyle{scrheadings}
% Inhalt bis Section rechts und Chapter links
\automark[section]{chapter}
% Mitte: leer
\chead{}

%
% mathematische symbole aus dem AMS Paket.
%
\usepackage{amsmath}
\usepackage{amssymb}

%
% Type 1 Fonts für bessere darstellung in PDF verwenden.
%
%\usepackage{mathptmx}           % Times + passende Mathefonts
%\usepackage[scaled=.92]{helvet} % skalierte Helvetica als \sfdefault
\usepackage{courier}            % Courier als \ttdefault

%
% Paket um Textteile drehen zu können
%
\usepackage{rotating}

%
% Paket für Farben im PDF
%
\usepackage{color}

%
% Paket für Links innerhalb des PDF Dokuments
%
\definecolor{LinkColor}{rgb}{0,0,0.5}
\usepackage[%
	pdftitle={An API Search Engine for Curry},% Titel der Diplomarbeit
	pdfauthor={Sandra Dylus},% Autor(en)
	pdfcreator={LaTeX, LaTeX with hyperref and KOMA-Script},% Genutzte Programme
	pdfsubject={Bachelor thesis}, % Betreff
	pdfkeywords={Curry, Haskell, API, search engine}]{hyperref} % Keywords halt :-)
\hypersetup{colorlinks=true,% Definition der Links im PDF File
	linkcolor=LinkColor,%
	citecolor=LinkColor,%
	filecolor=LinkColor,%
	menucolor=LinkColor,%
	pagecolor=LinkColor,%
	urlcolor=LinkColor}

%
% Paket um LIstings sauber zu formatieren.
%
\usepackage[savemem]{listings}
\lstloadlanguages{TeX}

%
% Listing Definationen für PHP Code
%
\definecolor{lbcolor}{rgb}{0.85,0.85,0.85}
\lstset{language=[LaTeX]TeX,
	numbers=left,
	stepnumber=1,
	numbersep=5pt,
	numberstyle=\tiny,
	breaklines=true,
	breakautoindent=true,
	postbreak=\space,
	tabsize=2,
	basicstyle=\ttfamily\footnotesize,
	showspaces=false,
	showstringspaces=false,
	extendedchars=true,
	backgroundcolor=\color{lbcolor}}
%
% ---------------------------------------------------------------------------
%

%
% Neue Umgebungen
%
\newenvironment{ListChanges}%
	{\begin{list}{$\diamondsuit$}{}}%
	{\end{list}}

%
% aller Bilder werden im Unterverzeichnis figures gesucht:
%
\graphicspath{{bilder/}}

%
% Literaturverzeichnis-Stil
%
\bibliographystyle{plain}

%
% Anführungsstriche mithilfe von \textss{-anzufuehrendes-}
%
\newcommand{\textss}[1]{"`#1"'}

%
% Strukturiertiefe bis subsubsection{} möglich
%
\setcounter{secnumdepth}{3}

%
% Dargestellte Strukturiertiefe im Inhaltsverzeichnis
%
\setcounter{tocdepth}{3}

%
% Zeilenabstand wird um den Faktor 1.5 verändert
%
%\renewcommand{\baselinestretch}{1.5}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\arrayhs


\begin{document}

% Römische Nummerierung für Sonderseiten, wie Verzeichnisse und Anhang
\pagenumbering{Roman}

% Titelblatt
% Die Titelseite
% Im folgenden kommen ein paar Variablen, die auszufüllen sind
% Bisher steht dort nur Musterinhalt
% Außerdem müssen zei Dateien erstellt werden, Bild/Logo/Emblem des Fachgebietes
% sowie der Universität

\newcommand{\trtitle}{An API Search Engine for Curry}
\newcommand{\trtype}{Bachelor Thesis}
\newcommand{\trauthor}{Sandra Dylus}
\newcommand{\trstrasse}{Gutenbergstra\ss e 3}
\newcommand{\trmatrikelnummer}{1083}
\newcommand{\trort}{24116 Kiel}
\newcommand{\trbetreuer}{M.o.Sc. Bj\"orn Peem\"oller}
\newcommand{\trprof}{Prof. Dr. Michael Hanus}
\newcommand{\trfachgebiet}{Programming Languages and Compiler Construction}
\newcommand{\trinstitut}{Computer Science}
\newcommand{\trfakultaet}{Technische Fakult\"at}
\newcommand{\truni}{Christian-Albrechts-Universit\"at zu Kiel}
\newcommand{\trdate}{\today}

\thispagestyle{empty}

% Kopfzeile mit Logos.
% Eventuell die \hspace{} je nach Logogröße anpassen
\begin{tabular}{lcr}
  % \includegraphics[scale=0.8]{dein_unilogo} & % dein_unilogo.jpg/.eps im Verzeichnis "bilder" ablegen
  % \hspace{2cm}  
\truni 
% \hspace{2cm} &
  % \includegraphics[scale=0.8]{dein_fglogo} % dein_fglogo.jpg/.eps im Verzeichnis "bilder" ablegen, Fachgebietslogo
  \\
\end{tabular}

\rule{\textwidth}{0.4pt}

\vspace{2.5cm}
\begin{center}
  \textbf{\LARGE \trtitle}
\end{center}
\vspace{2cm}

\begin{center}
  \textbf{\trtype} \\
  \trfachgebiet \\
  \trprof \\
  Department for \trinstitut \\
  % \trfakultaet \\
  \truni \\[0.5cm]
  % vorgelegt von \\
  \textbf{\trauthor}
\end{center}

\vspace{1cm}


\begin{center}
\begin{tabular}{ll}
Advised by & \trbetreuer \\
\end{tabular}
\end{center}

\vfill

\begin{tabular}{l}
\trauthor \\
Matrikelnummer:  \trmatrikelnummer \\
\trstrasse \\
\trort
\end{tabular}

\rule{\textwidth}{0.4pt}

% Verzeichnisse
% Kopfzeile links Kapitel, rechts leer
\renewcommand{\chaptermark}[1]{\markboth{\thechapter\ #1}{}}
\ihead{\leftmark}
\ohead{}
%
% Inhaltsverzeichnis
%
\tableofcontents

%
% Abbildungsverzeichnis
%
\listoffigures

%
% Tabellenverzeichnis
%
\listoftables

% Merke mir die römische Seitenzahl in 'roemisch' und setzte Nummeriernung 
% auf arabisch für die eigentlichen Kapitel
\newpage
\newcounter{roemisch}
\setcounter{roemisch}{\value{page}}
\pagenumbering{arabic}

% Die einzelnen Kapitel
% Kopfzeile: links Kapitel, rechts Sektion
\ihead{\leftmark}
\ohead{\rightmark}
\chapter{Introduction}
Once upon a time ...
\section{Motivation}
Curr(y)gle > Hayoo!
\section{Structure}
At first \hyperref[preliminaries]{Chapter \ref*{preliminaries}} gives
the preliminiaries to understand this thesis. This includes basic
information about the programming language Curry, a tool to generate
documentation, and the Holumbus framework that is used to build the
search engine in connection with this thesis. In
\hyperref[analysis]{Chapter \ref*{analysis}} we analyze the
requirements to create an API search engine for Curry. It outlines the
first ideas for the following implementation, which is given in
\hyperref[implementation]{Chapter \ref*{implementation}}. Thereby we
focus on the most important implementation ideas and decisions. At the
very end we consider the results of this development. Also we give a
short outlook on features or ideas to expand the given result.
\chapter{Preliminaries}\label{preliminaries}
This chapter gives a brief introduction to background information
that are necessary to comprehend the following chapters. The first
section gives an introduction to the programming language Curry. It
outlines main concepts and features of the language and gives short
explanations for a better understanding. The Curry implementation we
refer to in the following sections is PAKCS\cite{pakcs}. Furthermore
we present CurryDoc\cite{currydoc}, a tool to generate documentation
that is distributed with PAKCS, in the second section. The last
section introduces the Holumbus\cite{holumbus} framework, a library
written in Haskell to configure and build search engines.

\section{The programming language Curry}\label{preliminaries:curry}

% Say that curry is a functional logic programming language and what
% this section is about.\\

Curry is a functional logic programming language, that is an
international development project to provide a platform for research
and teaching mostly. As the description suggest, it offers features of
both programming paradigms. The first subsection will start with some general
features, followed by two subsections that cover
functional and logical concepts of Curry.

% Start with the structure of a curry program. \\
\subsection{General overview}
Like in Haskell, a program consists of function definitions and data
structures. A Curry module \emph{Test} is a program that is saved as
\emph{Test.curry}.
% After that explain how a function definition looks like and how
% pattern matching works (mention left-hand and right-hand
% side). Currys layout applies to the so called off-side rule. Add
% that Curry is strongly-typed and also type-inferred, so a signature
% is optional. \\
The syntax of a program is quite similar to Haskell, where function
application are also written in juxtaposition.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addTwo}\;\Varid{x}\mathrel{=}\Varid{x}\mathbin{+}\mathrm{2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The left-hand side of this function \ensuremath{\Varid{addTwo}\;\Varid{x}} is evaluated to the
right-hand side \ensuremath{\Varid{x}\mathbin{+}\mathrm{2}}, i.e. the call \ensuremath{\Varid{addTwo}\;\mathrm{3}} yields \ensuremath{\mathrm{3}\mathbin{+}\mathrm{3}\mathrel{=}\mathrm{5}}. Curry supports function definition with pattern matching, which is
often used in functional and logical programming languages. That means
that instantiated values like \ensuremath{\Conid{True}} and \ensuremath{\Conid{False}} can stand on the
left-hand side of a definition. The boolean operation \emph{not} is a
good example for a definition with pattern matching, since the result
depends on the input. The definition distinguishes between more than
one value , so we have to write one rule for each possible input
value.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\neg \mathbin{::}\Conid{Bool}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\neg \;\Conid{False}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\neg \;\Conid{True}\mathrel{=}\Conid{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The first line indicates that the function expects a boolean value as
argument and yields to a boolean value as well\footnote{The symbol \ensuremath{\to }
  will be used for \emph{->} throughout this thesis}. The following two
lines are rules, that describe that \ensuremath{\neg \;\Conid{False}} yields \ensuremath{\Conid{True}}, whereas
\ensuremath{\neg \;\Conid{True}} yields \ensuremath{\Conid{False}}. There are no more possible values for the
argument of the function \ensuremath{\neg }, since Curry is a strongly-typed
language and \ensuremath{\Conid{True}} and \ensuremath{\Conid{False}} are the only possible values with
boolean type.  In addition Curry also allows polymorphism. You can use
polymorphism for functions that work independent of the value's
type. For instance the identity function just returns the argument
that you apply to the function. This means you can apply the function
to all types of values, because the type does not matter. You use a
type variable in your type signature to indicate a polymorphic
type. The following code presents the type signature of the identity
function.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{id}\mathbin{::}\Varid{a}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{id}\;\Varid{value}\mathrel{=}\Varid{value}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Overall a strong type system as well as polymorphism and pattern
matching are among Curry's general features. The
next section covers functional characteristics of Curry.
% Mention that there are more concepts provided by Curry, which can be
% grouped by their underlying paradigm (use it as connection to the
% following subsections). Also the evaluation models are introduced.\\

% Curry is a functional logic programming language. As the name suggests
% it offers features of both programming paradigms. This section will
% outline the basic characteristics that Curry uses and give a short
% introduction to these characteristics.

% A program written in Curry is a collection of function definitions and
% data structures, which can be organized as a module. A module with the
% name \emph{M} is saved as \emph{M.curry} and can be imported in other
% modules. 
% The syntax of function definitions is quite similar to
% Haskell. Most functions are used as prefix operators, so the
% application of a function to an expression is denoted by
% juxtaposition. Arithmetic operators like |+| or |-| are infix
% operators like in the mathematical notation. Furthermore Curry also
% supports a conditional expression that corresponds to
% \emph{if-then-else}-expressions of other programming languages.

% In general one can say that Curry combines the features of the
% functional programming language Haskell and the logic programming
% language Prolog.

% \begin{itemize}
% \item pattern matching
% \item types (success)
% \item strongly typed
% \item type inference algorithm
% \item (pakcs) lazy, but incomplete - the strategy evaluates
%   non-deterministic choices sequentially instead of concurrently
% \item statically scoped (depends on layout - also: layout/off-side
%   rule), local scope with where and let
% \end{itemize}
\subsection{Functional features}\label{preliminaries:curryInfo}
% Begin with data structures that als can be defined by the user. Use
% CurryInfo as example.\\
The boolean values mentioned in the previous section are part of the
predefined data structures.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Bool}\mathrel{=}\Conid{True}\mid \Conid{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This code defines a data structure with the name \emph{Bool} that has
to constructors \ensuremath{\Conid{False}} and \ensuremath{\Conid{True}} with the type \ensuremath{\Conid{Bool}}. In this case
the constructors are unary. Let's define a data structure that is more
interesting and will be used in the following chapters. For example a
data structure that represents a Curry program, because we want to
create an API search engine for Curry. You can save a Curry program as
a module and it exists of functions and types (data structures).
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{CurryInfo}\mathrel{=}\Conid{CurryInfo}\;\Conid{ModuleInfo}\;[\mskip1.5mu \Conid{FunctionInfo}\mskip1.5mu]\;[\mskip1.5mu \Conid{TypeInfo}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In this example \emph{CurryInfo} is the name of the type and also the
name of the constructor. As a constructor it needs three arguments, a
\ensuremath{\Conid{ModuleInfo}} and a list of \ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}}. We define
these data structures that hold the information about specific
proporties of the program in chapter 3.

% Introduce the idea of higher-order functions.\\
In Curry functions are first-class citizens. This means that they can
appear as argument of an expression or even in a data structure. The
most popular use-case is the manipulation of all elements of a list by
a given function. PAKCS provides the function map, which also exists
in Haskell, that takes two arguments, a function and a list and
returns a list. The important thing is, that the type of the function
matches the elements of the list. For a example a function, that
converts an integer to a character can be applied to a list of
integers and yields to list of characters. The following code presents
the a definition of the function map.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{map}\mathbin{::}(\Varid{a}\to \Varid{b})\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{b}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{map}\;\Varid{function}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{map}\;\Varid{function}\;(\Varid{element}\mathbin{:}\Varid{list})\mathrel{=}\Varid{function}\;\Varid{element}\mathbin{:}\Varid{map}\;\Varid{list}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The syntax for lists is the same as in Haskell. \ensuremath{[\mskip1.5mu \mskip1.5mu]} is the empty
list, whereas \ensuremath{\mathrm{1}\mathbin{:}\mathrm{2}\mathbin{:}\mathrm{3}\mathbin{:}[\mskip1.5mu \mskip1.5mu]} is the same as \ensuremath{[\mskip1.5mu \mathrm{1},\mathrm{2},\mathrm{3}\mskip1.5mu]} or \ensuremath{\mathrm{1}\mathbin{:}[\mskip1.5mu \mathrm{2},\mathrm{3}\mskip1.5mu]}. The
first representation is often used in pattern matching, to use the
first element of the list in the right-hand side of the
definition. 
The first line presents the type signature. The function
\ensuremath{(\Varid{a}\to \Varid{b})} takes a value of an unspecific type and returns another
unspecific type. The second argument is a list of elements with the
type, that the function expects. Furthermore the resulting list
contains elements that have the same type as the resulting type of the
function. 
The definition of map says that an empty list yields an
empty list, whereas the function is applied to
the elements of a list with at least one element recursively.\\

% Explain lazy evaluation. Mention infinite structures.
The last functional concept Curry supports is \emph{lazy
  evaluation}. In general an expression is evaluated by replacing the
left-hand side of a definition by the right-hand side. The evaluation
proceeds one replacement after another until it yields a value. A
value is an expression that only consists of built-in data structures
or literals. If the last replacement does not result in a value, the
evaluation fails. If an evaluation has more than one possible
replacement step, so called subexpression can be evaluated. Lazy
evaluation means that such a subexpression is only evaluated, if its
result is necessary to continue the evaluation.\\

In summary Curry's functional programming features covers data
structures, higher-order functions and lazy evaluation as evaluation
strategy. Since the logic characteristics of Curry induce that
there is another strategy besides lazy evaluation, we will go one to
the next section and take a closer look into these characteristics.
\subsection{Logic features}
% Start with the connection between functional and logical programming:
% introduce the logical feature of non-deterministic functions. Therefor
% give an example for a rule and later a non-deterministic function.\\

Besides the already mentioned functional characteristics, Curry also
offers non-deterministic functions and logical variables.
Logic programming languages consist of rules, for example a constant
function that represents my favourite number.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{favouriteNumber}\;\Conid{Sandra}\mathrel{=}\mathrm{7}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Let's now assume that I don't have one, but two favourite
numbers. Curry as a hybrid of functional and logic programming language
allows multiple rules for function definitions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{favouriteNumber}\;\Conid{Sandra}\mathrel{=}\mathrm{3}{}\<[E]%
\\
\>[B]{}\Varid{favouriteNumber}\;\Conid{Sandra}\mathrel{=}\mathrm{7}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This function is non-deterministic because it returns different values
for the same input. The pattern of this function overlaps in
functional programming languages, but Curry's ability to search for
results allows to define those non-deterministic functions.\\

% After that explain how logical variables work.\\
% Give an example request with free variables. Mention the similarity
% to Prolog.
Curry also offers logical variables. A variable is called logical, if
it appears on the right-hand side but not on the left-hand side of a
rule. Free variables are unbound values, that are instantiated to
evaluate an expression. It is possible, that it exists more than one
binding, since Curry computes all possible solutions of an expression.

% As connection to free variables, mention the evaluation methods
% ``narrowing'' and ``residuation'' next. Give an example with boolean and
% constraint equality. Connect this to flexible and rigid functions.\\

Curry provides two different approaches to evaluate an expression with
logical variables. The first approach suspends the evaluation in hopes
that the logical variable will be bound due to another evaluation of
an expression. If there is no other expression to bind the value, the
evaluation fails.This approach is called residuation and Curry uses it
for boolean operators like the boolean equality \ensuremath{==}.  The second
approach, called narrowing, guesses a value for an unbound
value. Constraint operators like the boolean constraint \ensuremath{\mathbin{=.=}} use
narrowing for evaluation. In this context Curry distinguishes two
types of operators: flexible operators that narrow and rigid operators
that use residuation. For example arithmetic (i.e. \ensuremath{\mathbin{+}}, \ensuremath{\mathbin{-}}, \ensuremath{\mathbin{*}} etc)
and other primitive operations are rigid. However these distinctions
do not have any significance for expressions without logical
variables, so called \emph{ground expressions}. As mentioned in the
previous section, Curry evaluates ground expressions with lazy
strategy.\\

Simply put, one can say that Curry combines the features of the
functional programming language Haskell and the logic programming
language Prolog.

% \begin{itemize}
% \item Non-determinism
%   \begin{itemize}
%   \item choose
%   \item vs flexible functions
%   \item not in IO!
%   \end{itemize}
% \end{itemize}
\section{Currydoc}\label{preliminaries:currydoc}
% Explain the idea of CurryDoc, mention the similarity to the known
% javadoc. Current status of the tool (HTML and LaTeX export).\\

CurryDoc is a tool to generate documentation for a program written in
Curry. The current version can generate either a HTML or \LaTeX~ file
as output. CurryDoc works similar to code generating tools like
javadoc\cite{javadoc} as it uses the comments in the source code, which
are provided by the user, to gain information about the function or
data structure. It also provides the type signatures of functions,
since Curry uses a type inferencer algorithm. In addition the CurryDoc tool
analyzes the program's structure and approximates the run-time
behavior to gain further information\cite{currydoc2}. This analysis includes information about
in-/completeness, overlapping pattern matches and non-/deterministic
functions.

Since CurryDoc is implemented in Curry, it uses the meta-programming
module \emph{Flat}\cite{flat2} that provides an intermediate language of the Curry
program to analyze the special function proporties. Such a
FlatCurry\cite{flat} program consists mainly of a list of functions, a
list of types and information about the module itself.
% As you may notice, these are the informations we want to provide for
% the API search engine.

% Introduce FlatCurry program as utility. What is FlatCurry? Give an example of a
% Curry program and the corresponding FlatCurry program.\\

\section{The Holumbus Framework}\label{preliminaries:holumbus}
The Holumbus Framework is a Haskell library created by students of FH
Wedel in connection with three master's theses\footnote{references
  here?}. Holumbus is a library to build and configure a search engine. The
main idea of the framework is to collect data with a specific
structure, like an API of a programming language, and to take
advantage of this structure to improve the search results. In addition
to the framework, they also build an example application named
\emph{Hayoo!}\cite{hayoo}, an API search engine for the functional
programming language Haskell.\\

The framework supports three steps to create a search engine: the
crawling, the indexing and the searching part itself. The search
engine produced in connection with this thesis uses the latter two steps. The
indexer preprocesses the documents to create the characteristical data
structure that is used to process a search query. Furthermore Holumbus
provides a data structure that represents the results of a search
query. This data structure corresponds to the structure of the
documents, which simplifies further processing.\\

\missingfigure{Holumbus structure}
\todo[noline]{ info about this structure in
  more detail}

\chapter{Analysis}\label{analysis}
This chapter looks into the requirements to build and run Curr(y)gle,
an API search engine for Curry. The first section deals with the
creation of an index, whereas the second and third section addresses
the process of searching for a query. In this context, we take a
closer look of the Holumbus framework and its features related to
searching and evaluate the criteria to accomplish a user-friendly
search mechanism. Furthermore we discuss the features Curr(y)gle
should provide to specify a search query. % Above all we need a web
% application to handle user queries, which is analyzed in the last
% section.

% Give a short summary about the following sections.\\

% What do we need to create this search engine? 
% The possibility to generate and update the index.\\
% The possibility to search for these informations in the index. At
% best: user-friendly \\

% What do we want above all?
% A web application for queries.

% \section{Currydoc}
\section{Creating the Index}
At first, we have to decide about the information we want to store in
the index. Secondly the data structure of the index and documents
provided by the Holumbus framework, that hold
these information, is presented.\\

The data we want to extract from a given Curry module includes at least
the list of defined functions and data structures. We also want to
consider the name, corresponding module and description of these
functions and data structures. Additionally general information about
the module like its name and author needs to be stored. Usually a web
crawler is applied to browse the world wide web for our data. But since Curry is
currently organized by the module documentation generated by CurryDoc,
we already have a mechanism to gain these information about a Curry
module. In fact, we even have more function related information as we
stated in the \hyperref[preliminaries:curryInfo]{previous chapter}. We
know if a function definition is non-deterministic or deterministic
and if a given function is flexible or rigid.

CurryDoc processes Curry modules and generates documentation as HTML
or \LaTeX{} output. For our index, we are not interested in any
document markup language, but the pure information about the Curry
module. This observation leads to the idea of generating a new readable data
structure as an extension to CurryDoc. In the process we take
advantage of the FlatCurry representation of a Curry module to access
these information we mentioned above. We discuss the actual
implementation in \hyperref[implementation:currydoc]{Section \ref{implementation:currydoc}}. But in
preparation of the next chapter, we introduce the data structure
\ensuremath{\Conid{TypeExpr}} that is provided by the Flat module (see
\hyperref[fig:typeExpr]{Figure \ref{fig:typeExpr}}).

\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{TypeExpr}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\Conid{TVar}\;\Conid{TVarIndex}{}\<[37]%
\>[37]{}\mbox{\onelinecomment  type variable}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{FuncType}\;\Conid{TypeExpr}\;\Conid{TypeExpr}{}\<[37]%
\>[37]{}\mbox{\onelinecomment  function type t1->t2}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{TCons}\;\Conid{QName}\;[\mskip1.5mu \Conid{TypeExpr}\mskip1.5mu]{}\<[37]%
\>[37]{}\mbox{\onelinecomment  type constructor application}{}\<[E]%
\\
\>[37]{}\mbox{\onelinecomment  TCons (module, name) typeargs}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{QName}\mathrel{=}(\Conid{String},\Conid{String}){}\<[35]%
\>[35]{}\mbox{\onelinecomment  (module, type or constructor  name)}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{TVarIndex}\mathrel{=}\Conid{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{FlatCurry data structure for type signatures}
\label{fig:typeExpr}
\end{figure}

\ensuremath{\Conid{TypeExpr}} represents type and function signatures. It consists of
three constructors to distinguish between a function type (\ensuremath{\Conid{FuncType}\;\Conid{TypeExpr}\;\Conid{TypeExpr}}), a type variable (\ensuremath{\Conid{TVar}\;\Conid{TVarIndex}}), and a type
constructor application (\ensuremath{\Conid{TCons}\;\Conid{QName}\;[\mskip1.5mu \Conid{TypeExpr}\mskip1.5mu]}). An unary type like
\ensuremath{\Conid{Bool}} is represented as a type constructor with an empty list,
i.e. without an application to type arguments. The following code
shows some signatures and their representation in the \ensuremath{\Conid{TypeExpr}} data
structure.

\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{TCons}\;(\Conid{Prelude},\Conid{Maybe})\;[\mskip1.5mu (\Conid{TCons}\;(\Conid{Prelude},\Conid{Int})\;[\mskip1.5mu \mskip1.5mu]),{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Conid{TCons}\;(\Conid{Prelude},[\mskip1.5mu \mskip1.5mu])\;[\mskip1.5mu (\Conid{TCons}\;(\Conid{Prelude},\Conid{Char}))\mskip1.5mu])\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The representation of \ensuremath{\Conid{Maybe}\;\Conid{Int}\;\Conid{String}} as \ensuremath{\Conid{TypeExpr}}}
\end{figure}
\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{FuncType}\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{IO})\;[\mskip1.5mu \Conid{TVar}\;\mathrm{97}\mskip1.5mu])\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{IO}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The representation of \ensuremath{\Conid{IO}\;\Varid{a}\to \Conid{IO}\;\Varid{a}} as \ensuremath{\Conid{TypeExpr}}}
\end{figure}
\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{FuncType}\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{Bool})\;[\mskip1.5mu \mskip1.5mu])\;(\Conid{FuncType}\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{Int})\;[\mskip1.5mu \mskip1.5mu]){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Conid{TCons}\;(\Conid{Prelude},\Conid{Int})\;[\mskip1.5mu \mskip1.5mu])){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The representation of \ensuremath{\Conid{Bool}\to \Conid{Int}\to \Conid{Int}} as \ensuremath{\Conid{TypeExpr}}}
\end{figure}

% What do we need to create an index that can be used for the Curry
% search engine?\\

% First: Curry specific information (CurryDoc)\\

% First start with the idea of the extension: instead of generating a
% document markup language, generate a readable data structure.\\

% Introduce the TypeExpr data structure that is part of the FlatCurry
% feature.\\

% Second: a data structure to hold the information (index and document
% structure from the Holumbus framework)\\
After we decide about the contents of the index, we need to discuss
the storage of these information. We make use of the Holumbus
framework that provides data structures to manage the collected
data. The main idea is to use two structures to store the data.
\ensuremath{\Conid{Documents}\;\Varid{a}} is a data structures to store the collected data, where
\ensuremath{\Varid{a}} is the type of the document. Secondly the framework provides a
structure \ensuremath{\Conid{Inverted}} for the actual index data structure that is
traversed in the search process. Simply put, the index stores pairs
\ensuremath{(\Conid{String},\Conid{String})}, where the second entry is the word that can be
searched and the first entry is the context of this word. An example
for our API search engine is a context \emph{description}, whose
corresponding \ensuremath{\Conid{String}} is the description text of a Curry module. This
design allows the association between the information in the index and
the corresponding document through a mapping. Another type provided by
the framework is \ensuremath{\Conid{HolumbusState}\;\Varid{a}}: a combination of index and
document, polymorph by the data the document holds. In
\hyperref[implementation:index]{Section \ref{implementation:index}} we
illustrate the use of these data
structures in our implementation.\\

To sum up, we want to extend the current CurryDoc implementation to
generate a new readable data structure about a given Curry
module. These information cover, among other things, function and data
structure definitions, user comments and description in the source
code, and general information about the module. This new data
structure determines the type of \ensuremath{\Conid{HolDocuments}\;\Varid{a}} and forms one part
of the index-document-duo that Holumbus provides. 
% \begin{itemize}
% \item HolDocuments - Stores the documents that correspond to the
%   index. A mapping is provided.
% \item HolIndex - Data structure to store the information, that is
%   traversed in the search process.
% \item HolumbusState a - the combination of index and document,
%   polymorph by the data the HolDocuments holds.
% \end{itemize}

\section{Searching}
% How do we search for the information in the index?
After creating the skeleton for the index and its storage, we want to
actually use these information in a search query. Thus the first step
is to think about the structure of a query, in the second
step we process the query and last we need a representation of the
results of the processed query for further use.\\

Thankfully these are all features the Holumbus framework provides. At
first we take a look at the search mechanism. The data structure
\ensuremath{\Conid{Query}} (see \hyperref[analysis:query]{Figure \ref{analysis:query}})
allows to search for a word and a phrase, both case-insensitive and
case-sensitive. Since the search depends on user-input, the framework
also allows something called \emph{fuzzy search} to scan for results
with spelling errors like transposed letters. Since the index data
structure of Holumbus uses pairs of words and contexts, a special
mechanism to search for these contexts is given. Furthermore the
structure provides binary operators like \ensuremath{\Conid{AND}}, \ensuremath{\Conid{OR}} and \ensuremath{\Conid{NOT}} to
combine multiple queries.
% Holumbus provides search mechanism with a special syntax.
\begin{figure}
\label{analysis:query}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Query}\mathrel{=}\Conid{Word}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{Phrase}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{CaseWord}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{CasePhrase}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{FuzzyWord}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{Specifier}\;[\mskip1.5mu \Conid{Context}\mskip1.5mu]\;\Conid{Query}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{Negation}\;\Conid{Query}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\mid \Conid{BinQuery}\;\Conid{BinOp}\;\Conid{Query}\;\Conid{Query}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{BinOp}\mathrel{=}\Conid{And}\mid \Conid{Or}\mid \Conid{But}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The \ensuremath{\Conid{Query}} data structure provided by the Holumbus
  framework}
\end{figure}

% And this data structure can be processed by processQuery (Holumbus.Query.Processor).
As next step, we pass the index, document and query to the function
\emph{processQuery} that, as the name suggests, processes the
query. When processing the query, Holumbus only matches for prefixes
of the given word or phrase in a query, we need to consider this
restriction when creating our index in
\hyperref[implementation:index]{Section
  \ref{implementation:index}}. The data structure we get as return
value is shown in \hyperref[analysis:result]{Figure
  \ref{analysis:result}}. Since we make use of this structure in our
implementation, let's take a closer look at the code. \ensuremath{\Conid{Result}\;\Varid{a}}
consists of the matching documents with type \ensuremath{\Varid{a}} as well as possible
word completions. The first is represented by \ensuremath{\Conid{DocHits}\;\Varid{a}} that is a
mapping of \ensuremath{\Conid{DocInfo}\;\Varid{a}} and the contexts. On the other hand \ensuremath{\Conid{DocInfo}\;\Varid{a}}
consists of the matching document and a score. By default this score
is calculated by the number of occurrences of the search query in the
document. But Holumbus also provides a mechanism to apply a customized
ranking function to calculate the score. \ensuremath{\Conid{WordHits}} illustrates the
word completions and is represented by a mapping of the possible completions
of the given prefix in combination with its score, i.e. \ensuremath{\Conid{WordInfo}}, and the contexts.\\
% Holumbus also provides a data structure that is returned after a query

\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Result}\;\Varid{a}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Result}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}\{\mskip1.5mu \Varid{docHits}{}\<[28]%
\>[28]{}\mathbin{::}(\Conid{DocHits}\;\Varid{a}){}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{},\Varid{wordHits}\mathbin{::}\Conid{WordHits}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{DocInfo}\;\Varid{a}\mathrel{=}\Conid{DocInfo}{}\<[E]%
\\
\>[B]{}\hsindent{17}{}\<[17]%
\>[17]{}\{\mskip1.5mu \Varid{document}\mathbin{::}(\Conid{Document}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{17}{}\<[17]%
\>[17]{},\Varid{docScore}\mathbin{::}\Conid{Score}{}\<[E]%
\\
\>[B]{}\hsindent{17}{}\<[17]%
\>[17]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{WordInfo}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{WordInfo}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}\{\mskip1.5mu \Varid{terms}{}\<[29]%
\>[29]{}\mathbin{::}\Conid{Terms}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{},\Varid{wordScore}\mathbin{::}\Conid{Score}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{DocHits}\;\Varid{a}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{DocIdMap}\;(\Conid{DocInfo}\;\Varid{a},\Conid{DocContextHits}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{DocContextHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Context}\;\Conid{DocWordHits}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{DocWordHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Word}\;\Conid{Positions}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{WordHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Word}\;(\Conid{WordInfo},\Conid{WordContextHits}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{WordContextHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Context}\;\Conid{WordDocHits}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{WordDocHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Occurrences}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{Score}{}\<[22]%
\>[22]{}\mathrel{=}\Conid{Float}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Terms}{}\<[22]%
\>[22]{}\mathrel{=}[\mskip1.5mu \Conid{String}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The \ensuremath{\Conid{Result}} data structure provided by the Holumbus
  framework}
\label{analysis:result}
\end{figure}

Summing up, we have discussed the mechanism to evaluate a query with
the Holumbus framework. The provided mechanism includes the data structures to represent a
query, which can be processed to a data structure consisting of the
matching documents and possible word completions.
% But first the user input has to be parsed into the query structure to
% start the processing.

\section{Parsing User-Queries}
% Which criteria do we want to search for? Modules, functions, types,
% signatures, and  det./non-det., flexible/rigid functions. \\
The next question is how to construct the query for a given
user-input. At first we have to decide about the criteria users can
search for. Since the index provides the pairs of contexts and search
words, we are able to restrict the search to all these context with
the help of the \ensuremath{\Conid{Query}} data structure and the \ensuremath{\Conid{Specifier}}
constructor. This structure of the index allows us to search for modules, functions,
types, signatures and all other contexts we use during the creation of
the index.\\

% First describe the idea, that the use of a specific language increases
% the usability. But it also restricts the user in her usage of the
% search engine, if this language gets more complex. So this results in
% a compromise between a simply to use language and a language that can
% be parsed.  Show the example of searching IO, where the restriction to
% modules minimizes the result.\\
The search mechanism as part of the user-experience is supposed to be
as simple as possible. The use of a specific language increases the
usability, since an expression has its explicit syntax. A good example
is the search term \ensuremath{\text{\tt ''}\;\Varid{io''}}, since in Curry \emph{IO} is the name for
a module, a type and a constructor. Furthermore there are many
functions in the IO module, that contain the word \emph{io}. Thus, the
search for \emph{io} results in a great amount of hits. We can
restrict the search to a specific context to reduce the number of
hits. Therefore we want to provide specifiers the user combinats with
the search term, for example \ensuremath{\text{\tt ''}\mathbin{:}\Varid{function}\;\Conid{IO''}} searches for \emph{IO}
in the context of function names only. But this special syntax
restricts the user in the use of the search engine, if the language
gets more complex. Thus to provide a user-friendly search engine, we
have to make a compromise between a simply to use language and a
language that can be parsed.

% Set the focus on signatures. Because Hayoo! does not find signatures with
% redundant parentheses, Curr(y)gle supports parenthesized signatures
% and parenthesized query parts in general. \\
Besides these specifiers we want to parse type signatures of Curry
functions and data structures. Since Hayoo! is not able to parse
redundant parenthesized signatures, we want to address this problem
with great care. Let's assume a beginner searches for a function with
the type signature \ensuremath{\text{\tt ''}\;\Conid{IO}\to (\Conid{IO}\;\Conid{Int})\;\text{\tt ''}}. The type \emph{IO Int} and
type constructors in general do not need parentheses, but as beginner
you might think they do. Thus we want to support parenthesized
signatures and parenthesized query parts in general.

Last but not least we want to provide binary conjunctions like
\emph{And}, \emph{Or} and \emph{Not}. On the one hand a combination of
more search words is desirable, because popular search engines like
Google\texttrademark~ support binary operations as feature. The popularity increases the
probability that users assume binary operations are standard features
and expect search engines to provide the conjunction of several search
terms. On the other hand if the desired result is still vague, a
combination of more search words by a disjunction \emph{Or} helps to
narrow down the
search results.\\
% In addition: binary operations/conjunctions. \\
% Explain that in most cases, a combination of more search words is
% desirable, because first popular search engines like Google\texttrademark~use this
% feature so it's common knowledge (the user expects this features) and
% second it's easier to search for more search words, if the desired
% result is still vague.

In the end we want to provide an intuitive but powerful syntax for the
search engine. With specifiers to restrict the search results to a
given context and with binary operations to narrow down or extend the
contexts, we want to provide a simple language for the user
queries. Additionally type signatures should be recognized, including
function, construction and primitive types as well as redundant
parenthesized signatures. As the number of the supported features
increases, the query gets more complex to read. Thus to reach this
goal, we need to analyse the user input and rebuild it as an
expression of our \ensuremath{\Conid{Query}} data structure. In
\hyperref[implementation:parser]{Section \ref{implementation:parser}}
we discuss our actual implementation.

% The parser becomes a complex, but very important matter.
\chapter{Implementation}\label{implementation}
% Mention that the implementation is done in Haskell or Curry.\\
% Give a short summary of the next sections.

This chapter presents the implementation of the search engine on the
basis of some code examples and the corresponding design ideas and
decisions. At first we take a look at the extension for the current
version of CurryDoc. In this context we illustrate the interaction
between this extension and the index creation. The latter determines
the topic of the second section. We specify the index and document
data in more detail and state some difficulties that arose due to the
usage of the Holumbus framework. The third section addresses the
implemented parser to convert the user input into a query that can be
processed by Holumbus. We illustrate the general idea and
implementation approach of a parser to introduce into the subject. The
last section covers features and implementations of the web
application for the search engine.  The implementations are mostly
written in the functional programming language Haskell; we use the
functional logic programming language Curry for the CurryDoc
extension only.\\

\todo[inline]{general section about the underlying environment?}

\section{CurryDoc extension}\label{implementation:currydoc}

In the previous chapter we discussed the general idea of an extension
for CurryDoc to generate a data structure. Later this data structure serves
as source for the index creation. In this section we take a look at
the implementation of this extension.

% Present the general structure of the |CurryInfo| data and the
% sub-structures |ModuleInfo|, |FunctionInfo| and |TypeInfo|.
Since CurryDoc is written in Curry, we implemented our extension in
Curry as well. With this decision we stand to benefit from already
implemented functionalities and on the other hand, using the same
programming language simplifies the integration of our
implementation with the current CurryDoc version.\\

CurryDoc uses the meta-programming language FlatCurry to gain an
intermediate data structure. We can use this data structure for our
purposes. Additionally, we can use other functions provided by
CurryDoc, that are already implemented. For example, CurryDoc supports
a special comment syntax to annotate the author and version of a
module. Furthermore the arguments and the return value of a function
can be described as well as general descriptions.

But at first, we discuss which information we want to provide in our
data structures. We already introduced \emph{CurryInfo} as structure
for a Curry program in the
\hyperref[preliminaries:currydoc:curryInfo]{second chapter}. As next
step we want to describe \ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}},
since they are a part of the \ensuremath{\Conid{CurryInfo}} data structure. You can take
a look at these data structures and their definitions in advance in
\hyperref[fig:curryInfo]{Figure \ref{fig:curryInfo}}.

\begin{figure}[h]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mbox{\onelinecomment  | The CurryInfo data holds information about the module, and}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment   corresponding  functions, data and type declaration of a given }{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment   Curry module.}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{CurryInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{CurryInfo}\;\Conid{ModuleInfo}\;[\mskip1.5mu \Conid{FunctionInfo}\mskip1.5mu]\;[\mskip1.5mu \Conid{TypeInfo}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\newline{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  | ModuleInfo holds information about the name, author,}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment     and the description of a given module.}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{ModuleInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ModuleInfo}\;\Conid{String}\;\Conid{String}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\newline{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  | FunctionInfo holds information about the name, signature, corresponding }{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  module, description and flexible/rigid status of a function and }{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  its non-/deterministic behaviour.}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{FunctionInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FunctionInfo}\;\Conid{String}\;(\Conid{QName},\Conid{TypeExpr})\;\Conid{String}\;\Conid{String}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FlexRigidResult}{}\<[E]%
\\
\>[B]{}\newline{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  | TypeInfo holds information about the name, signature, type variables,}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  corresponding module, and description of a given type.}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{TypeInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{TypeInfo}\;\Conid{String}\;[\mskip1.5mu (\Conid{QName},[\mskip1.5mu \Conid{TypeExpr}\mskip1.5mu])\mskip1.5mu]\;[\mskip1.5mu \Conid{Int}\mskip1.5mu]\;\Conid{String}\;\Conid{String}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The data structures representing a Curry program}
\label{fig:curryInfo}
\end{figure}

Like the name suggests, \ensuremath{\Conid{ModuleInfo}} represents the data corresponding
to a Curry module. The main information about a module consists of its
name, author and description. We can also provide the version number
of the implementation or the imported modules, but we decided against
it. The latter seems to be useless information for the search engine,
since the Curry modules are highly interrelated. Thus, searching for a
module results in a great amount of hits, since every correlating
module will be shown as well. Furthermore we think the version number
is not a significant characteristic for a module. Therefore we decided
to focus on the three mentioned proporties only.

\ensuremath{\Conid{FunctionInfo}} consists of characteristics for a given function like
the function's name and description. Additionally we decide to add the
corresponding module to provide a connection between the function and
its module. This decision is based on the cause that we do not keep
the \ensuremath{\Conid{CurryInfo}} data structure as whole for the index construction,
but the three arguments consisting of the list of functions, the list
of types and the module information. Thanks to FlatCurry, we can also
access function characteristics like nondeterminism and determinism,
along with the information if a given function is rigid or
flexible. Since these are important characteristics to differ between
Curry functions, \ensuremath{\Conid{FunctionInfo}} stores these information as
property. In addition FlatCurry provides a data structure \ensuremath{\Conid{TypeExpr}}
to describe type signatures (see \hyperref[fig:typeExpr]{last
  chapter}), furthermore we get the actual definition of a
function. We use a function's type signature as part of the
\ensuremath{\Conid{FunctionInfo}} data structure, but decided against the usage of a
function's definition since we could not think of a relevant use-case
for our search engine.

The data structure for types looks quite similar to
\ensuremath{\Conid{FunctionInfo}}. \ensuremath{\Conid{TypeInfo}} consists of a type's name, description and
corresponding module. Since FlatCurry provides type signatures for
functions, we also get information about constructors for a given
type. Therefore we store a list of \ensuremath{\Conid{TypeExpr}} representing the type's
constructors. Additionally \ensuremath{\Conid{TypeInfo}} holds a list of integer to
represent possible type variables. The decision to use integer corresponds to
the definition of \ensuremath{\Conid{TypeExpr}}, where type variables are represented as
integer as well. \\

In the end, we feed the \ensuremath{\Conid{CurryInfo}} data structure with the specific
module, function and type information of a given Curry program and our
CurryDoc extension writes the data structure into a
\emph{.cdoc}-file. The final CurryDoc version allows two mechanisms to
generate the \ensuremath{\Conid{CurryInfo}} structure. You can generate the
\emph{.cdoc}-file only or you initiate the HTML generation, where the
\emph{.cdoc}-file is also part of the output. In
\hyperref[a:currydoc]{Appendix \ref{a:currydoc}} we provide further
instruction for the usage of CurryDoc.

Due to the similar syntax, we can use the same data structures in
Haskell as in Curry to exchange those structures. More precisely, we
can read the \emph{.cdoc}-file within our Haskell implementation and
work with the data structure. In order to do that, we need a Haskell
program that defines all the data structures used in \ensuremath{\Conid{CurryInfo}}
including the nested structures. Thus, we generate \ensuremath{\Conid{CurryInfo}} to use
it as data structure in the process of the index creation.
% The same data structure is used on the Haskell side that implements
% the search engine.

\section{Indexer}\label{implementation:index}

This section illustrates how to create the index for our search
engine. In our analysis, we discussed some data structures to handle
the index creation and the information we want to store. In the
following, we talk the advantages and disadvantages of using the
Holumbus framework and describe our implementation of the index
creation in more detail.
The following implementation is done in the functional logic
programming language Haskell. This decision allows us to use the
Holumbus framework for our purpose and a good number of functional,
pure and strict features.\\

In the previous section we already mentioned the required preparation
to create the index. On the Haskell side, we need to define the data
structures we use to build the \ensuremath{\Conid{CurryInfo}} structure. Then we can read
the file produced by the CurryDoc extension for further usage. Since
\ensuremath{\Conid{CurryInfo}} and its substructures \ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}} and
\ensuremath{\Conid{TypeInfo}} already provide the information we want to store in our
index, it is not necessary to filter these structures. Instead, we
only have to process these data to fit the data structures provided by
Holumbus. In the end we can either create a new index by writing each
structure to a file to store our information or update an existing
index with additional Curry modules. In order to do that, we load the
index and document files and merge them with new data. Due to lazy
evaluation, we cannot read and write to the same file; it is
not assured that we finish reading before we start to rewrite the
file. Therefore we have to write temporary files and rename these
files afterwards to guarantee a clean outcome.

During the testing phase of the indexer, we noticed problems regarding
duplicate data. In particular, when we add a Curry module to the
index twice, there is no mechanism to detect the duplicated data. For
that reason only we added a list of the modules that are stored in the
index as output file. So every time we update the index with a given
module, we check if it already exists in the saved list. We only start
the processing of the data, if the module does not occur in our list
and on the other hand, we add the module's name to the list.\\

In the previous chapter, we introduced the idea of storing two
structures: an index \ensuremath{\Conid{Inverted}} and a document \ensuremath{\Conid{Documents}\;\Varid{a}}. \todo{index would be better} In the following, we present this
idea in more detail, beginning with the document. At first, we take
closer look at the data structure itself. Holumbus provides us with
\ensuremath{\Conid{Documents}\;\Varid{a}} can be described as mapping of yet another data
structure \ensuremath{\Conid{Document}\;\Varid{a}} and an unique identifier (see
\hyperref[fig:documents]{Figure \ref{fig:documents}}). Each \ensuremath{\Conid{Document}\;\Varid{a}} consists of a title, an URI and customizable information. The
latter has the type \ensuremath{\Varid{a}} and determines the type for document. In order
to have a faster access to a specific document, \ensuremath{\Conid{Documents}\;\Varid{a}} also
stores the highest document id used in the mapping as well as a
mapping from the document's uri to the document's identifier.\\

\begin{figure}[h]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Document}\;\Varid{a}\mathrel{=}\Conid{Document}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\{\mskip1.5mu \Varid{title}{}\<[28]%
\>[28]{}\mathbin{::}\Conid{Title}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{},\Varid{uri}{}\<[28]%
\>[28]{}\mathbin{::}\Conid{URI}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{},\Varid{custom}\mathbin{::}(\Conid{Maybe}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\newline{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{Documents}\;\Varid{a}\mathrel{=}\Conid{Documents}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{}\{\mskip1.5mu \Varid{idToDoc}{}\<[32]%
\>[32]{}\mathbin{::}(\Conid{DocMap}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{},\Varid{docToId}{}\<[32]%
\>[32]{}\mathbin{::}\Conid{URIMap}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{},\Varid{lastDocId}\mathbin{::}\Conid{DocId}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Holumbus' data structure for a document and a collection of documents}
\label{fig:documents}
\end{figure}

For the creation of the index, we have to feed \ensuremath{\Conid{Documents}\;\Varid{a}} with
actual data. As mentioned before, we can read the \ensuremath{\Conid{CurryInfo}}
structure and use it in the process. The first idea is to construct a
document with \ensuremath{\Conid{CurryInfo}} as data structure for the custom
information. This idea is easy to implement since we just use the
unmodified data structure that CurryDoc produces. As consequence, all
the information in the corresponding index map to this one
document. When we search our index for an information, we can relate a
given search result only to the corresponding \ensuremath{\Conid{CurryInfo}}; we cannot
distinguish if the search result is associated to the module, function
or type information of the given \ensuremath{\Conid{CurryInfo}} structure. In order to
provide a more differentiated representation of a Curry module in the
index, we choose not to use \ensuremath{\Conid{CurryInfo}} but its substructures
\ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}} as document types,
i.e. the custom information. However, if we want to distinguish
between these three sources of information, we need to store three
types of documents. Nevertheless this decision allows us to relate the
information of a Curry module to its functions, types or information
about the module itself.\todo{Not specific enough: each function and
  data structure of the module has a document, all functions are
  collected in documents as well as types} This design already determines the decision
regarding the title and the uri. The title corresponds to the name of
the function, type or module. The value of the URI is an argument to
fill by the user when generating the index; the URI can point to a
local or online source for documentation. We designed the URI
representation for the HTML-documentation provided by CurryDoc, since
the current main source for Curry documentation, that can be accessed
online\footnote{\url{http://www.informatik.uni-kiel.de/~pakcs/lib/CDOC}},
is generated via CurryDoc. Since this HTML-structure of a Curry module
documentation provides anchors to the module's defined functions and
data structures, we use this link mechanism for our URIs as well. In
\hyperref[fig:uri]{Figure \ref{fig:uri}} you can see that modules use
the base URI given by the user, whereas functions and data structures
are build by combining the base URI, an anchor symbol and the
function's or data structure's name.\\

\begin{figure}[h]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mbox{\onelinecomment  Function to build a document.}{}\<[E]%
\\
\>[B]{}\Varid{doc}\mathbin{::}\Conid{String}\to (\Varid{a}\to \Conid{String})\to \Conid{Uri}\;\Varid{a}\to \Varid{a}\to \Conid{Document}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{doc}\;\Varid{uriPath}\;\Varid{fiName}\;\Varid{uriType}\;\Varid{info}\mathrel{=}\Conid{Document}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{title}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{fiName}\;\Varid{info}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{uri}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{uriP}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{custom}\mathrel{=}\Conid{Just}\;\Varid{info}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\mathbf{where}\;\Varid{uriP}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{case}\;\Varid{uriType}\;\mathbf{of}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Conid{ModuleUri}\;\Varid{baseUri}\to {}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\Varid{uriPath}\plus \Varid{baseUri}\;\Varid{info}\plus \text{\tt \char34 .html\char34}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Conid{FctOrTypeUri}\;\Varid{baseUri}\;\Varid{name}\to {}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\Varid{uriPath}\plus \Varid{baseUri}\;\Varid{info}\plus \text{\tt \char34 .html\char34}\plus \text{\tt \char34 \#\char34}\plus \Varid{name}\;\Varid{info}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\newline{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  Data to represent uri,}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  functions and types use anchors, i.e. moduleName.html$$functionName.}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{Uri}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ModuleUri}\;(\Varid{a}\to \Conid{String})\mid {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FctOrTypeUri}\;(\Varid{a}\to \Conid{String})\;(\Varid{a}\to \Conid{String}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Function to build \ensuremath{\Conid{Document}\;\Varid{a}} and data structure to
  distinguish between an URI with or without anchors}
\label{fig:uri}
\end{figure}

% First mention that the interesting parts (that we want to add to the
% index) are already filtered by the CurryDoc part. So the indexer only
% processes the information to the structure provided by the Holumbus
% framework (HolumbusState). First the .cdoc file is read and resolved
% into the index and document structure.

% Present the output (files) the indexer produces. In addition to that, say something
% about refreshing and checking the list of modules.

% After that introduce the concept of documents and index. Mention the
% three different kinds of documents for the three structures: module,
% function, type.
% \begin{code}
% -- || Pair of index and documents of the type ModuleInfo
% type CurryModIndexerState         = HolumbusState ModuleInfo

% -- || Pair of index and documents of the type FunctionInfo
% type CurryFctIndexerState         = HolumbusState FunctionInfo

% -- || Pair of index and documents of the type TypeInfo
% type CurryTypeIndexerState        = HolumbusState TypeInfo
% \end{code}

Note the difficulties of updating the index, because the data
structure of the loaded pair of index and document differs from
]HolumbusState a. Conversion of \ensuremath{\Conid{Inverted}} to \ensuremath{\Conid{CompactInverted}} and
\ensuremath{\Conid{Documents}\;\Varid{a}} to \ensuremath{\Conid{SmallDocuments}\;\Varid{a}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{LoadedIndexerState}\;\Varid{a}\mathrel{=}(\Conid{CompactInverted},\Conid{SmallDocuments}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Explain how each kind of information (description, module name,
function signature etc) is combined with its context, and that these
are stored in the index. Note that these information can be extracted by the
context again. Focus on signatures and the problem of prefix search.

Refer to the appendix, where the usage of the curryIndexer is
explained.

\section{Parser}\label{implementation:parser}

% First describe the idea, that the use of a specific language increases
% the usability. But it also restricts the user in her usage of the
% search engine, if this language gets more complex. So this results in
% a compromise between a simply to use language and a language that can
% be parsed.  Show the example of searching IO, where the restriction to
% modules minimizes the result.

% After that list all language components that describe the restriction
% to contexts (module, function, type, signature and  non-/deterministic,
% flexible, rigid functions.

% Set the focus on signatures. Because Hayoo does not find signatures with
% redundant parenthesis, Curr(y)gle supports parenthesized signatures
% and parenthesized query parts in general.  

Explain the general idea of parsers: a parser is used to analyze the
user query with these different kinds of information. While parsing
the string, a new data structure is composed for further use. This
data structure is provided by the Holumbus framework and is used to
start the process that returns the search results.

Introduce the parser type that is parametrized with the type to parse and the
resulting type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Parser}\;\sigma \;\alpha \mathrel{=}[\mskip1.5mu \sigma \mskip1.5mu]\to [\mskip1.5mu (\alpha ,[\mskip1.5mu \sigma \mskip1.5mu])\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Explain the operator \ensuremath{(\rotatebox[origin=c]{90}{$\ominus$})} that applies two parsers and concats the
parsing results.  
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\rotatebox[origin=c]{90}{$\ominus$})\mathbin{::}\Conid{Parser}\;\Varid{s}\;\Varid{a}\to \Conid{Parser}\;\Varid{s}\;\Varid{a}\to \Conid{Parser}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{p}~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{q}\mathrel{=}(\lambda \Varid{ts}\to \Varid{p}\;\Varid{ts}\plus \Varid{q}\;\Varid{ts}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Introduce the combination of two parsers that is similar to a monadic
bind operator. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\circledast)\mathbin{::}\Conid{Parser}\;\Varid{s}\;(\Varid{a}\to \Varid{b})\to \Conid{Parser}\;\Varid{s}\;\Varid{a}\to \Conid{Parser}\;\Varid{s}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{p}\circledast\Varid{q}\mathrel{=}\lambda \Varid{ts}\to [\mskip1.5mu (\Varid{f}\;\Varid{x},\Varid{ts}_{2})\mid (\Varid{f},\Varid{ts}_{1})\leftarrow \Varid{p}\;\Varid{ts},(\Varid{x},\Varid{ts}_{2})\leftarrow \Varid{q}\;\Varid{ts}_{1}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now show that a function has to be applied, to use the binding operator.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\circledS)\mathbin{::}(\Varid{a}\to \Varid{b})\to \Conid{Parser}\;\Varid{s}\;\Varid{a}\to \Conid{Parser}\;\Varid{s}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{f}~\circledS~\Varid{p}\mathrel{=}{}\<[14]%
\>[14]{}\lambda \Varid{ts}\to [\mskip1.5mu (\Varid{f}\;\Varid{x},\Varid{ts}_{1})\mid (\Varid{x},\Varid{ts}_{1})\leftarrow \Varid{p}\;\Varid{ts}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Present a simple example that can parse a given character.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parsePredicate}\mathbin{::}(\Conid{Char}\to \Conid{Bool})\to \Conid{Parser}\;\Conid{Char}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parsePredicate}\;\Varid{predicate}\;(\Varid{t}\mathbin{:}\Varid{ts}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{predicate}\;\Varid{t}\mathrel{=}[\mskip1.5mu ([\mskip1.5mu \mskip1.5mu],\Varid{ts})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{otherwise}{}\<[17]%
\>[17]{}\mathrel{=}[\mskip1.5mu ([\mskip1.5mu \mskip1.5mu],\Varid{t}\mathbin{:}\Varid{ts})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{parsePredicate}\;\anonymous \;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Present the concept by writing a parser for expressions with or without
parentheses using \ensuremath{\rotatebox[origin=c]{90}{$\ominus$}} and \ensuremath{\circledast}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mbox{\onelinecomment  Parses an opening parenthesis by using the predicate parser.}{}\<[E]%
\\
\>[B]{}\Varid{parseOpenParenthesis}\mathbin{::}\Conid{Parser}\;\Conid{Char}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parseOpenParenthesis}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{parsePredicate}\;(\text{\tt '('}==){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mbox{\onelinecomment  Parses an closing parenthesis.}{}\<[E]%
\\
\>[B]{}\Varid{parseCloseParenthesis}\mathbin{::}\Conid{Parser}\;\Conid{Char}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parseCloseParenthesis}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{parsePredicate}\;(\text{\tt ')'}==){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mbox{\onelinecomment  Parses a sequence of alpha numeric characters. }{}\<[E]%
\\
\>[B]{}\Varid{parseExpression}\mathbin{::}\Conid{Parser}\;\Conid{Char}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parseExpression}\;(\Varid{t}\mathbin{:}\Varid{ts})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{if}\;\Varid{isAlphaNum}\;\Varid{t}\;\mathbf{then}\;\Varid{parseExpression}\;\Varid{ts}\;\mathbf{else}\;[\mskip1.5mu ([\mskip1.5mu \mskip1.5mu],\Varid{t}\mathbin{:}\Varid{ts})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{parseExpression}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mbox{\onelinecomment  Parses an expression or a parenthesized expression.}{}\<[E]%
\\
\>[B]{}\Varid{parenthesizedExpression}\mathbin{::}\Conid{Parser}\;\Conid{Char}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parenthesizedExpression}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}((\mathbin{\char92 \char95 }\Varid{expr}\;\anonymous \to \Varid{expr}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}~\circledS~\Varid{parseOpenParenthesis}\circledast\Varid{parseExpression}\circledast\Varid{parseCloseParenthesis}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{parseExpression}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Give a definition of the language (EBNF(?) / appendix). 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{55}{@{}>{\hspre}l<{\hspost}@{}}%
\column{58}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{query}\mathbin{:=}\Varid{expr}\;[\mskip1.5mu \Varid{expr}\mskip1.5mu]\mid \Varid{expr}\;\Varid{bool}\;\Varid{expr}\mid (\Varid{expr}){}\<[E]%
\\
\>[B]{}\Varid{expr}\mathbin{:=}(\Varid{expr})\mid \Varid{specifier}\mid \Varid{signature}\mid \Varid{string}{}\<[E]%
\\
\>[B]{}\Varid{bool}\mathbin{:=}\text{\tt \char34 AND\char34}\mid \text{\tt \char34 OR\char34}\mid \text{\tt \char34 NOT\char34}{}\<[E]%
\\
\>[B]{}\Varid{specifier}\mathbin{:=}{}\<[16]%
\>[16]{}\text{\tt \char34 :module\char34}\;[\mskip1.5mu \Varid{alphaNum}\mskip1.5mu]\mid \text{\tt \char34 :signature\char34}\;{}\<[55]%
\>[55]{}[\mskip1.5mu \Varid{signature}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\mid {}\<[5]%
\>[5]{}\text{\tt \char34 :function\char34}\;[\mskip1.5mu \Varid{alphaNum}\mskip1.5mu]\mid \text{\tt \char34 :flexible\char34}\mid \text{\tt \char34 :rigid\char34}\mid {}\<[58]%
\>[58]{}\text{\tt \char34 :nondet\char34}\mid \text{\tt \char34 :det\char34}{}\<[E]%
\\
\>[B]{}\Varid{signature}\mathbin{:=}\Conid{Upper}\;\Varid{alphaNum}\mid \Varid{function}\mid \Varid{constructor}{}\<[E]%
\\
\>[B]{}\Varid{function}\mathbin{:=}\Varid{signature}\;\text{\tt \char34 ->\char34}\;\Varid{signature}{}\<[40]%
\>[40]{}\mid \Varid{lower}\;\text{\tt \char34 ->\char34}\;\Varid{signature}\mid {}\<[E]%
\\
\>[B]{}\Varid{signature}\;\text{\tt \char34 ->\char34}\;\Varid{lower}{}\<[E]%
\\
\>[B]{}\Varid{constructor}\mathbin{:=}\Conid{Upper}\;\Varid{alphaNum}\;\Varid{signature}\mid \Conid{Upper}\;\Varid{alphaNum}\;\Varid{lower}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Web application}
\chapter{Conclusion}\label{conclusion}
\section{Summary and Results}
\section{Outlook}

% Setze Numerierung wieder auf römisch zurück und setzte von oben fort
% Wert ist demnach der von 'roemisch'
\newpage
\pagenumbering{Roman}
\setcounter{page}{\value{roemisch}}

% Appendix, falls vorhanden
\appendix
\chapter{CurryDoc Instruction}\label{a:currydoc}

\chapter{User-Query Syntax}\label{a:syntax}

% Literaturverzeichnis
\bibliography{literatur/bib}

% Eidesstattliche Erklärung
% \input{extras/eidesstattliche}

\end{document}
