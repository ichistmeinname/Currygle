% Header mit Deklarationen
\documentclass[%
	pdftex,%              PDFTex verwenden
	a4paper,%             A4 Papier
	oneside,%             Einseitig
	chapterprefix,%       Kapitel anschreiben als Kapitel
	headsepline,%         Linie nach Kopfzeile
	%footsepline,%         Linie vor Fusszeile
	%pointlessnumbers,%     Nummern ohne abschließenden Punkt
	12pt%                 Grössere Schrift, besser lesbar am bildschrim
]{scrbook}
%
% Paket für Übersetzungen ins Deutsche
%
% \usepackage[french,ngerman]{babel}

\usepackage{todonotes}
\usepackage{multirow}

%
% Pakete um Latin1 Zeichnensätze verwenden zu können und die dazu
% passenden Schriften.
%
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

%
% Paket für Quotes
%
% \usepackage[babel,french=guillemets,german=swiss]{csquotes}

%
% Paket zum Erweitern der Tabelleneigenschaften
%
\usepackage{array}

%
% Paket für schönere Tabellen
%
\usepackage{booktabs}

%
% Paket um Grafiken einbetten zu können
%
\usepackage{graphicx}

%
% Spezielle Schrift im Koma-Script setzen.
%
\usepackage{titlesec}
\newcommand*{\justifyheading}{\raggedleft}
\titleformat{\chapter}[display]
  {\normalfont\Huge\bfseries\justifyheading}{\thechapter}
  {10pt}{\Huge}
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}
% \setkomafont{sectioning}{\normalfont\bfseries}
\setkomafont{captionlabel}{\normalfont\bfseries} 
\setkomafont{pagehead}{\normalfont\bfseries} % Kopfzeilenschrift
\setkomafont{descriptionlabel}{\normalfont\bfseries}

%
% Zeilenumbruch bei Bildbeschreibungen.
%
\setcapindent{1em}

%
% Kopf und Fußzeilen
%
\usepackage{scrpage2}
\pagestyle{scrheadings}
% Inhalt bis Section rechts und Chapter links
\automark[section]{chapter}
% Mitte: leer
\chead{}

%
% mathematische symbole aus dem AMS Paket.
%
\usepackage{amsmath}
\usepackage{amssymb}

%
% Type 1 Fonts für bessere darstellung in PDF verwenden.
%
%\usepackage{mathptmx}           % Times + passende Mathefonts
%\usepackage[scaled=.92]{helvet} % skalierte Helvetica als \sfdefault
\usepackage{courier}            % Courier als \ttdefault

%
% Paket um Textteile drehen zu können
%
\usepackage{rotating}

%
% Paket für Farben im PDF
%
\usepackage{color}

%
% Paket für Links innerhalb des PDF Dokuments
%
\definecolor{LinkColor}{rgb}{0,0,0.5}
\usepackage[%
	pdftitle={An API Search Engine for Curry},% Titel der Diplomarbeit
	pdfauthor={Sandra Dylus},% Autor(en)
	pdfcreator={LaTeX, LaTeX with hyperref and KOMA-Script},% Genutzte Programme
	pdfsubject={Bachelor thesis}, % Betreff
	pdfkeywords={Curry, Haskell, API, search engine}]{hyperref} % Keywords halt :-)
\hypersetup{colorlinks=true,% Definition der Links im PDF File
	linkcolor=LinkColor,%
	citecolor=LinkColor,%
	filecolor=LinkColor,%
	menucolor=LinkColor,%
	pagecolor=LinkColor,%
	urlcolor=LinkColor}

%
% Paket um LIstings sauber zu formatieren.
%
\usepackage[savemem]{listings}
\lstloadlanguages{TeX}

%
% Listing Definationen für PHP Code
%
\definecolor{lbcolor}{rgb}{0.85,0.85,0.85}
\lstset{language=[LaTeX]TeX,
	numbers=left,
	stepnumber=1,
	numbersep=5pt,
	numberstyle=\tiny,
	breaklines=true,
	breakautoindent=true,
	postbreak=\space,
	tabsize=2,
	basicstyle=\ttfamily\footnotesize,
	showspaces=false,
	showstringspaces=false,
	extendedchars=true,
	backgroundcolor=\color{lbcolor}}
%
% ---------------------------------------------------------------------------
%

%
% Neue Umgebungen
%
\newenvironment{ListChanges}%
	{\begin{list}{$\diamondsuit$}{}}%
	{\end{list}}

%
% aller Bilder werden im Unterverzeichnis figures gesucht:
%
\graphicspath{{bilder/}}

%
% Literaturverzeichnis-Stil
%
\bibliographystyle{plain}

%
% Anführungsstriche mithilfe von \textss{-anzufuehrendes-}
%
\newcommand{\textss}[1]{"#1"}

%
% Strukturiertiefe bis subsubsection{} möglich
%
\setcounter{secnumdepth}{3}

%
% Dargestellte Strukturiertiefe im Inhaltsverzeichnis
%
\setcounter{tocdepth}{3}

%
% Zeilenabstand wird um den Faktor 1.5 verändert
%
%\renewcommand{\baselinestretch}{1.25}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\arrayhs




\begin{document}

% Römische Nummerierung für Sonderseiten, wie Verzeichnisse und Anhang
\pagenumbering{Roman}

% Titelblatt
% Die Titelseite
% Im folgenden kommen ein paar Variablen, die auszufüllen sind
% Bisher steht dort nur Musterinhalt
% Außerdem müssen zei Dateien erstellt werden, Bild/Logo/Emblem des Fachgebietes
% sowie der Universität

\newcommand{\trtitle}{An API Search Engine for Curry}
\newcommand{\trtype}{Bachelor Thesis}
\newcommand{\trauthor}{Sandra Dylus}
\newcommand{\trstrasse}{Gutenbergstra\ss e 3}
\newcommand{\trmatrikelnummer}{1083}
\newcommand{\trort}{24116 Kiel}
\newcommand{\trbetreuer}{M.o.Sc. Bj\"orn Peem\"oller}
\newcommand{\trprof}{Prof. Dr. Michael Hanus}
\newcommand{\trfachgebiet}{Programming Languages and Compiler Construction}
\newcommand{\trinstitut}{Computer Science}
\newcommand{\trfakultaet}{Technische Fakult\"at}
\newcommand{\truni}{Christian-Albrechts-Universit\"at zu Kiel}
\newcommand{\trdate}{\today}

\thispagestyle{empty}

% Kopfzeile mit Logos.
% Eventuell die \hspace{} je nach Logogröße anpassen
\begin{tabular}{lcr}
  % \includegraphics[scale=0.8]{dein_unilogo} & % dein_unilogo.jpg/.eps im Verzeichnis "bilder" ablegen
  % \hspace{2cm}  
\truni 
% \hspace{2cm} &
  % \includegraphics[scale=0.8]{dein_fglogo} % dein_fglogo.jpg/.eps im Verzeichnis "bilder" ablegen, Fachgebietslogo
  \\
\end{tabular}

\rule{\textwidth}{0.4pt}

\vspace{2.5cm}
\begin{center}
  \textbf{\LARGE \trtitle}
\end{center}
\vspace{2cm}

\begin{center}
  \textbf{\trtype} \\
  \trfachgebiet \\
  \trprof \\
  Department for \trinstitut \\
  % \trfakultaet \\
  \truni \\[0.5cm]
  % vorgelegt von \\
  \textbf{\trauthor}
\end{center}

\vspace{1cm}


\begin{center}
\begin{tabular}{ll}
Advised by & \trbetreuer \\
\end{tabular}
\end{center}

\vfill

\begin{tabular}{l}
\trauthor \\
Matrikelnummer:  \trmatrikelnummer \\
\trstrasse \\
\trort
\end{tabular}

\rule{\textwidth}{0.4pt}

% Verzeichnisse
% Kopfzeile links Kapitel, rechts leer
\renewcommand{\chaptermark}[1]{\markboth{\thechapter\ #1}{}}
\ihead{\leftmark}
\ohead{}
%
% Inhaltsverzeichnis
%
\tableofcontents

%
% Abbildungsverzeichnis
%
\listoffigures

%
% Tabellenverzeichnis
%
\listoftables

% Merke mir die römische Seitenzahl in 'roemisch' und setzte Nummeriernung 
% auf arabisch für die eigentlichen Kapitel
\newpage
\newcounter{roemisch}
\setcounter{roemisch}{\value{page}}
\pagenumbering{arabic}

% Die einzelnen Kapitel
% Kopfzeile: links Kapitel, rechts Sektion
\ihead{\leftmark}
\ohead{\rightmark}
\chapter{Introduction}
Once upon a time ...
\section{Motivation}
Curr(y)gle > Hayoo!
\section{Structure}
At first \hyperref[preliminaries]{Chapter \ref*{preliminaries}} gives
the preliminiaries to understand this thesis. %
This includes basic information about the programming language Curry,
a tool to generate documentation, and the Holumbus framework that is
used to build the search engine in connection with this thesis. %
In \hyperref[analysis]{Chapter \ref*{analysis}} we analyze the
requirements to create an API search engine for Curry. %
It outlines the first ideas for the following implementation, which is
given in \hyperref[implementation]{Chapter \ref*{implementation}}. %
Thereby we focus on the most important implementation ideas and
decisions. %
At the very end we consider the results of this development. %
Also we give a short outlook on features or ideas to expand the given
result. %
\chapter{Preliminaries}\label{preliminaries}
This chapter gives a brief introduction to background information that
are necessary to comprehend the following chapters. %
The first section gives an introduction to the programming language
Curry. %
It outlines main concepts and features of the language and gives short
explanations for a better understanding. %
The Curry implementation we refer to in the following sections is
PAKCS\cite{pakcs}. Furthermore we present CurryDoc\cite{currydoc}, a
tool to generate documentation that is distributed with PAKCS, in the
second section. %
The last section introduces the Holumbus\cite{holumbus} framework, a
library written in Haskell to configure and build search engines. %

\section{The programming language Curry}\label{preliminaries:curry}

% Say that curry is a functional logic programming language and what
% this section is about.\\

Curry is a functional logic programming language, that is an
international development project to provide a platform for research
and teaching mostly. %
As the description suggest, it offers features of both programming
paradigms. %
The first subsection will start with some general features, followed
by two subsections that cover functional and logical concepts of
Curry. %

% Start with the structure of a curry program. \\
\subsection{General Overview}
Like in Haskell, a program consists of function definitions and data
structures. %
A Curry module \emph{Test} is a program that is saved as
\emph{Test.curry}. %
% After that explain how a function definition looks like and how
% pattern matching works (mention left-hand and right-hand
% side). Currys layout applies to the so called off-side rule. Add
% that Curry is strongly-typed and also type-inferred, so a signature
% is optional. \\
The syntax of a program is quite similar to Haskell, where function
application are also written in juxtaposition. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addTwo}\;\Varid{x}\mathrel{=}\Varid{x}\mathbin{+}\mathrm{2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The left-hand side of this function \ensuremath{\Varid{addTwo}\;\Varid{x}} is evaluated to the
right-hand side \ensuremath{\Varid{x}\mathbin{+}\mathrm{2}}, i.e. the call \ensuremath{\Varid{addTwo}\;\mathrm{3}} yields \ensuremath{\mathrm{3}\mathbin{+}\mathrm{3}\mathrel{=}\mathrm{5}}. %
Curry supports function definition with pattern matching, which is
often used in functional and logical programming languages. %
That means that instantiated values like \ensuremath{\Conid{True}} and \ensuremath{\Conid{False}} can stand
on the left-hand side of a definition. %
The boolean operation \emph{not} is a good example for a definition
with pattern matching, since the result depends on the input. %
The definition distinguishes between more than one value , so we have
to write one rule for each possible input value. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\neg \mathbin{::}\Conid{Bool}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\neg \;\Conid{False}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\neg \;\Conid{True}\mathrel{=}\Conid{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The first line indicates that the function expects a boolean value as
argument and yields to a boolean value as well\footnote{The symbol
  \ensuremath{\to } will be used for \emph{->} throughout this thesis}. %
The following two lines are rules, that describe that \ensuremath{\neg \;\Conid{False}}
yields \ensuremath{\Conid{True}}, whereas \ensuremath{\neg \;\Conid{True}} yields \ensuremath{\Conid{False}}. %
There are no more possible values for the argument of the function
\ensuremath{\neg }, since Curry is a strongly-typed language and \ensuremath{\Conid{True}} and \ensuremath{\Conid{False}}
are the only possible values with boolean type. %
In addition Curry also allows polymorphism. You can use polymorphism
for functions that work independent of the value's type. %
For instance the identity function just returns the argument that you
apply to the function. %
This means you can apply the function to all types of values, because
the type does not matter. %
You use a type variable in your type signature to indicate a
polymorphic type. %
The following code presents the type signature of the identity
function. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{id}\mathbin{::}\Varid{a}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{id}\;\Varid{value}\mathrel{=}\Varid{value}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Overall a strong type system as well as polymorphism and pattern
matching are among Curry's general features. %
The next section covers functional characteristics of Curry.
% Mention that there are more concepts provided by Curry, which can be
% grouped by their underlying paradigm (use it as connection to the
% following subsections). Also the evaluation models are introduced.\\

% Curry is a functional logic programming language. As the name suggests
% it offers features of both programming paradigms. This section will
% outline the basic characteristics that Curry uses and give a short
% introduction to these characteristics.

% A program written in Curry is a collection of function definitions and
% data structures, which can be organized as a module. A module with the
% name \emph{M} is saved as \emph{M.curry} and can be imported in other
% modules. 
% The syntax of function definitions is quite similar to
% Haskell. Most functions are used as prefix operators, so the
% application of a function to an expression is denoted by
% juxtaposition. Arithmetic operators like |+| or |-| are infix
% operators like in the mathematical notation. Furthermore Curry also
% supports a conditional expression that corresponds to
% \emph{if-then-else}-expressions of other programming languages.

% In general one can say that Curry combines the features of the
% functional programming language Haskell and the logic programming
% language Prolog.

% \begin{itemize}
% \item pattern matching
% \item types (success)
% \item strongly typed
% \item type inference algorithm
% \item (pakcs) lazy, but incomplete - the strategy evaluates
%   non-deterministic choices sequentially instead of concurrently
% \item statically scoped (depends on layout - also: layout/off-side
%   rule), local scope with where and let
% \end{itemize}
\subsection{Functional Features}\label{preliminaries:curryInfo}
% Begin with data structures that als can be defined by the user. Use
% CurryInfo as example.\\
The boolean values mentioned in the previous section are part of the
predefined data structures. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Bool}\mathrel{=}\Conid{True}\mid \Conid{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This code defines a data structure with the name \emph{Bool} that has
to constructors \ensuremath{\Conid{False}} and \ensuremath{\Conid{True}} with the type \ensuremath{\Conid{Bool}}. %
In this case the constructors are unary. %
Let's define a data structure that is more interesting and will be
used in the following chapters. %
For example a data structure that represents a Curry program, because
we want to create an API search engine for Curry. %
You can save a Curry program as a module and it exists of functions
and types (data structures). %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{CurryInfo}\mathrel{=}\Conid{CurryInfo}\;\Conid{ModuleInfo}\;[\mskip1.5mu \Conid{FunctionInfo}\mskip1.5mu]\;[\mskip1.5mu \Conid{TypeInfo}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In this example \emph{CurryInfo} is the name of the type and also the
name of the constructor. %
As a constructor it needs three arguments, a \ensuremath{\Conid{ModuleInfo}} and a list
of \ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}}. %
We define these data structures that hold the information about
specific proporties of the program in chapter 3. %

% Introduce the idea of higher-order functions.\\
In Curry functions are first-class citizens. %
This means that they can appear as argument of an expression or even
in a data structure. %
The most popular use-case is the manipulation of all elements of a
list by a given function. %
PAKCS provides the function map, which also exists in Haskell, that
takes two arguments, a function and a list and returns a list. %
The important thing is, that the type of the function matches the
elements of the list. %
For a example a function, that converts an integer to a character can
be applied to a list of integers and yields to list of characters. %
The following code presents the a definition of the function map. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{map}\mathbin{::}(\Varid{a}\to \Varid{b})\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{b}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{map}\;\Varid{function}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{map}\;\Varid{function}\;(\Varid{element}\mathbin{:}\Varid{list})\mathrel{=}\Varid{function}\;\Varid{element}\mathbin{:}\Varid{map}\;\Varid{list}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The syntax for lists is the same as in Haskell. %
\ensuremath{[\mskip1.5mu \mskip1.5mu]} is the empty list, whereas \ensuremath{\mathrm{1}\mathbin{:}\mathrm{2}\mathbin{:}\mathrm{3}\mathbin{:}[\mskip1.5mu \mskip1.5mu]} is the same as \ensuremath{[\mskip1.5mu \mathrm{1},\mathrm{2},\mathrm{3}\mskip1.5mu]} or
\ensuremath{\mathrm{1}\mathbin{:}[\mskip1.5mu \mathrm{2},\mathrm{3}\mskip1.5mu]}. %
The first representation is often used in pattern matching, to use the
first element of the list in the right-hand side of the definition. %
The first line presents the type signature. %
The function \ensuremath{(\Varid{a}\to \Varid{b})} takes a value of an unspecific type and returns
another unspecific type. %
The second argument is a list of elements with the type, that the
function expects. %
Furthermore the resulting list contains elements that have the same
type as the resulting type of the function. %
The definition of map says that an empty list yields an empty list,
whereas the function is applied to the elements of a list with at
least one element recursively. %

% Explain lazy evaluation. Mention infinite structures.
The last functional concept Curry supports is \emph{lazy
  evaluation}. %
In general an expression is evaluated by replacing the left-hand side
of a definition by the right-hand side. %
The evaluation proceeds one replacement after another until it yields
a value. %
A value is an expression that only consists of built-in data
structures or literals. %
If the last replacement does not result in a value, the evaluation
fails. %
If an evaluation has more than one possible replacement step, so
called subexpression can be evaluated. %
Lazy evaluation means that such a subexpression is only evaluated, if
its result is necessary to continue the evaluation. %

In summary Curry's functional programming features covers data
structures, higher-order functions and lazy evaluation as evaluation
strategy. %
Since the logic characteristics of Curry induce that there is another
strategy besides lazy evaluation, we will go one to the next section
and take a closer look into these characteristics. %
\subsection{Logic Features}
% Start with the connection between functional and logical programming:
% introduce the logical feature of non-deterministic functions. Therefor
% give an example for a rule and later a non-deterministic function.\\

Besides the already mentioned functional characteristics, Curry also
offers non-deterministic functions and logical variables. %
Logic programming languages consist of rules, for example a constant
function that represents my favourite number. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{favouriteNumber}\;\Conid{Sandra}\mathrel{=}\mathrm{7}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Let's now assume that I don't have one, but two favourite numbers. %
Curry as a hybrid of functional and logic programming language allows
multiple rules for function definitions. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{favouriteNumber}\;\Conid{Sandra}\mathrel{=}\mathrm{3}{}\<[E]%
\\
\>[B]{}\Varid{favouriteNumber}\;\Conid{Sandra}\mathrel{=}\mathrm{7}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This function is non-deterministic because it returns different values
for the same input. %
The pattern of this function overlaps in functional programming
languages, but Curry's ability to search for results allows to define
those non-deterministic functions. %

% After that explain how logical variables work.\\
% Give an example request with free variables. Mention the similarity
% to Prolog.
Curry also offers logical variables. %
A variable is called logical, if it appears on the right-hand side but
not on the left-hand side of a rule. %
Free variables are unbound values, that are instantiated to evaluate
an expression. %
It is possible, that it exists more than one binding, since Curry
computes all possible solutions of an expression. %

% As connection to free variables, mention the evaluation methods
% ``narrowing'' and ``residuation'' next. Give an example with boolean and
% constraint equality. Connect this to flexible and rigid functions.\\

Curry provides two different approaches to evaluate an expression with
logical variables. %
The first approach suspends the evaluation in hopes that the logical
variable will be bound due to another evaluation of an expression. %
If there is no other expression to bind the value, the evaluation
fails. %
This approach is called residuation and Curry uses it for boolean
operators like the boolean equality \ensuremath{==}. %
The second approach, called narrowing, guesses a value for an unbound
value. %
Constraint operators like the boolean constraint \ensuremath{\mathbin{=.=}} use narrowing
for evaluation. %
In this context Curry distinguishes two types of operators: flexible
operators that narrow and rigid operators that use residuation. %
For example arithmetic (i.e. \ensuremath{\mathbin{+}}, \ensuremath{\mathbin{-}}, \ensuremath{\mathbin{*}} etc) and other primitive
operations are rigid. %
However these distinctions do not have any significance for
expressions without logical variables, so called \emph{ground
  expressions}. %
As mentioned in the previous section, Curry evaluates ground
expressions with lazy strategy.\\

Simply put, one can say that Curry combines the features of the
functional programming language Haskell and the logic programming
language Prolog. %

% \begin{itemize}
% \item Non-determinism
%   \begin{itemize}
%   \item choose
%   \item vs flexible functions
%   \item not in IO!
%   \end{itemize}
% \end{itemize}
\section{Currydoc}\label{preliminaries:currydoc}
% Explain the idea of CurryDoc, mention the similarity to the known
% javadoc. Current status of the tool (HTML and LaTeX export).\\

CurryDoc is a tool to generate documentation for a program written in
Curry. %
The current version can generate either a HTML or \LaTeX~ file as
output. %
CurryDoc works similar to code generating tools like
javadoc\cite{javadoc} as it uses the comments in the source code,
which are provided by the user, to gain information about the function
or data structure. %
It also provides the type signatures of functions, since Curry uses a
type inferencer algorithm. %
In addition the CurryDoc tool analyzes the program's structure and
approximates the run-time behavior to gain further
information\cite{currydoc2}. %
This analysis includes information about in-/completeness, overlapping
pattern matches and non-/deterministic functions. %

Since CurryDoc is implemented in Curry, it uses the meta-programming
module \emph{Flat}\cite{flat2} that provides an intermediate language
of the Curry program to analyze the special function proporties. %
Such a FlatCurry\cite{flat} program consists mainly of a list of
functions, a list of types and information about the module itself. %
% As you may notice, these are the informations we want to provide for
% the API search engine.

% Introduce FlatCurry program as utility. What is FlatCurry? Give an example of a
% Curry program and the corresponding FlatCurry program.\\

\section{The Holumbus Framework}\label{preliminaries:holumbus}
The Holumbus Framework is a Haskell library created by students of FH
Wedel in connection with three master's theses\footnote{references
  here?}. %
Holumbus is a library to build and configure a search engine. %
The main idea of the framework is to collect data with a specific
structure, like an API of a programming language, and to take
advantage of this structure to improve the search results. %
In addition to the framework, they also build an example application
named \emph{Hayoo!}\cite{hayoo}, an API search engine for the
functional programming language Haskell. %

The framework supports three steps to create a search engine: the
crawling, the indexing and the searching part itself. %
The search engine produced in connection with this thesis uses the
latter two steps. %
The indexer preprocesses the documents to create the
characteristically data structure that is used to process a search
query. %
Furthermore Holumbus provides a data structure that represents the
results of a search query. %
This data structure corresponds to the structure of the documents,
which simplifies further processing. %

\missingfigure{Holumbus structure}
\todo[noline]{ info about this structure in
  more detail}

\chapter{Analysis}\label{analysis}
This chapter looks into the requirements to build and run Curr(y)gle,
an API search engine for Curry. %
The first section deals with the creation of an index, whereas the
second and third section addresses the process of searching for a
query. %
In this context, we take a closer look of the Holumbus framework and
its features related to searching and evaluate the criteria to
accomplish a user-friendly search mechanism. %
Furthermore we discuss the features Curr(y)gle should provide to
specify a search query. %
% Above all we need a web application to handle user queries, which is
% analyzed in the last section.

% Give a short summary about the following sections.\\

% What do we need to create this search engine? 
% The possibility to generate and update the index.\\
% The possibility to search for these informations in the index. At
% best: user-friendly \\

% What do we want above all?
% A web application for queries.

% \section{Currydoc}
\section{Creating the Index}
At first, we have to decide about the information we want to store in
the index. %
Secondly the data structure of the index and documents provided by the
Holumbus framework, that hold these information, is presented.\\

The data we want to extract from a given Curry module includes at
least the list of defined functions and data structures. %
We also want to consider the name, corresponding module and
description of these functions and data structures. %
Additionally general information about the module like its name and
author needs to be stored. %
Usually a web crawler is applied to browse the world wide web for our
data. %
But since Curry is currently organized by the module documentation
generated by CurryDoc, we already have a mechanism to gain these
information about a Curry module. %
In fact, we even have more function related information as we stated
in the \hyperref[preliminaries:curryInfo]{previous chapter}. %
We know if a function definition is non-deterministic or deterministic
and if a given function is flexible or rigid. %

CurryDoc processes Curry modules and generates documentation as HTML
or \LaTeX{} output. %
For our index, we are not interested in any document markup language,
but the pure information about the Curry module. %
This observation leads to the idea of generating a new readable data
structure as an extension to CurryDoc. %
In the process we take advantage of the FlatCurry representation of a
Curry module to access these information we mentioned above. %
We discuss the actual implementation in
\hyperref[implementation:currydoc]{Section
  \ref{implementation:currydoc}}. %
But in preparation of the next chapter, we introduce the data
structure \ensuremath{\Conid{TypeExpr}} that is provided by the Flat module. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{TypeExpr}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\Conid{TVar}\;\Conid{TVarIndex}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{FuncType}\;\Conid{TypeExpr}\;\Conid{TypeExpr}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{TCons}\;\Conid{QName}\;[\mskip1.5mu \Conid{TypeExpr}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\ensuremath{\Conid{TypeExpr}} represents type and function signatures. It consists of
three constructors to distinguish between a function type (\ensuremath{\Conid{FuncType}\;\Conid{TypeExpr}\;\Conid{TypeExpr}}), a type variable (\ensuremath{\Conid{TVar}\;\Conid{TVarIndex}}), and a type
constructor application (\ensuremath{\Conid{TCons}\;\Conid{QName}\;[\mskip1.5mu \Conid{TypeExpr}\mskip1.5mu]}). %
For the latter, the list of \ensuremath{\Conid{TypeExpr}} stand for the type
arguments. %
Furthermore, \ensuremath{\Conid{TVarIndex}} is just a type synonym for \ensuremath{\Conid{Int}} and \ensuremath{\Conid{QName}}
represents a qualified name consisting of the module's name and the
function's or type constructor's name. %
\ensuremath{\Conid{QName}} is a type synonym for a tuple \ensuremath{(\Conid{String},\Conid{String})}. %
An unary type like \ensuremath{\Conid{Bool}} is represented as a type constructor with an
empty list, i.e. without an application to type arguments. %
The following code shows some signatures and their representation in
the \ensuremath{\Conid{TypeExpr}} data structure. %

\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{TCons}\;(\Conid{Prelude},\Conid{Maybe})\;[\mskip1.5mu (\Conid{TCons}\;(\Conid{Prelude},\Conid{Int})\;[\mskip1.5mu \mskip1.5mu]),{}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}(\Conid{TCons}\;(\Conid{Prelude},[\mskip1.5mu \mskip1.5mu])\;[\mskip1.5mu (\Conid{TCons}\;(\Conid{Prelude},\Conid{Char}))\mskip1.5mu])\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The representation of \ensuremath{\Conid{Maybe}\;\Conid{Int}\;\Conid{String}} as \ensuremath{\Conid{TypeExpr}}}
\end{figure}
\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{FuncType}\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{IO})\;[\mskip1.5mu \Conid{TVar}\;\mathrm{97}\mskip1.5mu])\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{IO}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The representation of \ensuremath{\Conid{IO}\;\Varid{a}\to \Conid{IO}\;\Varid{a}} as \ensuremath{\Conid{TypeExpr}}}
\end{figure}
\begin{figure}[h!]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{FuncType}\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{Bool})\;[\mskip1.5mu \mskip1.5mu])\;(\Conid{FuncType}\;(\Conid{TCons}\;(\Conid{Prelude},\Conid{Int})\;[\mskip1.5mu \mskip1.5mu]))\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Conid{TCons}\;(\Conid{Prelude},\Conid{Int})\;[\mskip1.5mu \mskip1.5mu])){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The representation of \ensuremath{\Conid{Bool}\to \Conid{Int}\to \Conid{Int}} as \ensuremath{\Conid{TypeExpr}}}
\end{figure}

% What do we need to create an index that can be used for the Curry
% search engine?\\

% First: Curry specific information (CurryDoc)\\

% First start with the idea of the extension: instead of generating a
% document markup language, generate a readable data structure.\\

% Introduce the TypeExpr data structure that is part of the FlatCurry
% feature.\\

% Second: a data structure to hold the information (index and document
% structure from the Holumbus framework)\\

After we decide about the contents of the index, we need to discuss
the storage of these information. %
We make use of the Holumbus framework that provides data structures to
manage the collected data and interfaces to operate on these
structures. %
The main idea is to use two structures to store the data, one for the
document we are indexing and the other one stores the actual data we
traverse when a search is performed. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{IndexerState}\;\Varid{i}\;\Varid{d}\;\Varid{a}\mathrel{=}\Conid{IndexerState}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{ixs\char95 index}{}\<[25]%
\>[25]{}\mathbin{::}\Varid{i}{}\<[39]%
\>[39]{}\mbox{\onelinecomment  the index type}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{ixs\char95 documents}{}\<[25]%
\>[25]{}\mathbin{::}(\Varid{d}\;\Varid{a}){}\<[39]%
\>[39]{}\mbox{\onelinecomment  the document type}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

At first, we introduce the data structures we use in our
implementation, that are provided by the framework. %
Secondly, we discuss the functionality of the interfaces. \\

In our implementation, we use \ensuremath{\Conid{Documents}\;\Varid{a}} as a data structures to
store the collected data, where \ensuremath{\Varid{a}} is the type of the document. %
Each document of a collection has its unique identifier. %
Secondly the framework provides a structure \ensuremath{\Conid{Inverted}} for the actual
index data structure that is traversed in the search process. %
Simply put, the index stores pairs \ensuremath{(\Conid{String},\Conid{String})}, where the
second entry is the word that can be searched and the first entry is
the context of this word. %
An example for our API search engine is a context \emph{description},
whose corresponding \ensuremath{\Conid{String}} is the description text of a Curry
module. %
As addition to the design, the identifier of the document is stored in
the index data structure as well to provide an association between the
index and the document the data was indexed from. %
Another type provided by the framework is \ensuremath{\Conid{HolumbusState}\;\Varid{a}}: a
combination of index and document, polymorph by the data the document
holds. %
In \hyperref[implementation:index]{Section \ref{implementation:index}}
we illustrate the use of these data structures in our
implementation.

Holumbus provides more than these two explicit data structures to
handle the storage, it rather has multiple implementations to choose
from. %
All these implementations of the document and index data structure are
instances of the provided interfaces. %
Therefore we introduce the main functionalities of the interfaces we
use in our implementation. %
\ensuremath{\Conid{HolIndex}} is the name of the interface for the \emph{actual index}
and the main functionalities we are interested in, are the provided
methods to create a new index and merge two existing indexes. %
We need the same functionality for \ensuremath{\Conid{HolDocuments}}, the interface for
document data structures. %
Besides methods to merge two \ensuremath{\Conid{Documents}\;\Varid{a}} and create a new \ensuremath{\Conid{Documents}\;\Varid{a}}, a function to change the identifier of a document in \ensuremath{\Conid{Documents}\;\Varid{a}}
and to insert a document into \ensuremath{\Conid{Documents}} is provided as well.\\

To sum up, we want to extend the current CurryDoc implementation to
generate a new readable data structure about a given Curry module. %
These information cover, among other things, function and data
structure definitions, user comments and description in the source
code, and general information about the module. %
This new data structure determines the type of \ensuremath{\Conid{HolDocuments}\;\Varid{a}} and
forms one part of the index-document-duo that Holumbus provides. %
% \begin{itemize}
% \item HolDocuments - Stores the documents that correspond to the
%   index. A mapping is provided.
% \item HolIndex - Data structure to store the information, that is
%   traversed in the search process.
% \item HolumbusState a - the combination of index and document,
%   polymorph by the data the HolDocuments holds.
% \end{itemize}

\section{Searching}
% How do we search for the information in the index?
After creating the skeleton for the index and its storage, we want to
actually use these information in a search query. %
Thus the first step is to think about the structure of a query, in the
second step we process the query and last we need a representation of
the results of the processed query for further use.\\

Thankfully these are all features the Holumbus framework provides. At
first we take a look at the search mechanism. %
The data structure \ensuremath{\Conid{Query}} allows to search for a word and a phrase,
both case-insensitive and case-sensitive. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Word}\;\Conid{String}\mathbin{::}\Conid{Query}{}\<[E]%
\\
\>[B]{}\Conid{Phrase}\;\Conid{String}\mathbin{::}\Conid{Query}{}\<[E]%
\\
\>[B]{}\Conid{CaseWord}\;\Conid{String}\mathbin{::}\Conid{Query}{}\<[E]%
\\
\>[B]{}\Conid{CasePhrase}\;\Conid{String}\mathbin{::}\Conid{Query}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Since the search depends on user-input, the framework also allows
something called \ensuremath{\Conid{FuzzyWord}\;\Conid{String}} to scan for results with spelling
errors like transposed letters. %
Since the index data structure of Holumbus uses pairs of words and
contexts, a special mechanism to search for these contexts is given. %
Furthermore the structure provides binary operators of the form \ensuremath{\Conid{BinQuery}\;\Conid{BinOp}\;\Conid{Query}\;\Conid{Query}} to combine multiple queries, where \ensuremath{\Conid{BinOp}} can be a
conjunction, disjunction or negation. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{BinOp}\mathrel{=}\Conid{And}\mid \Conid{Or}\mid \Conid{But}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

% And this data structure can be processed by processQuery (Holumbus.Query.Processor).
As next step, we pass the index, document and query to the function
\emph{processQuery} that, as the name suggests, processes the query. %
When processing the query, Holumbus only matches for prefixes of the
given word or phrase in a query, we need to consider this restriction
when creating our index in \hyperref[implementation:index]{Section
  \ref{implementation:index}}. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Result}\;\Varid{a}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Result}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{docHits}{}\<[14]%
\>[14]{}\mathbin{::}(\Conid{DocHits}\;\Varid{a}){}\<[E]%
\\
\>[B]{},\Varid{wordHits}{}\<[14]%
\>[14]{}\mathbin{::}\Conid{WordHits}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As return value, we get the data structure \ensuremath{\Conid{Result}\;\Varid{a}}, that consists
of the matching documents with type \ensuremath{\Varid{a}} as well as possible word
completions. %
The first is represented by \ensuremath{\Conid{DocHits}\;\Varid{a}} that is a mapping of \ensuremath{\Conid{DocInfo}\;\Varid{a}}, the contexts and the document's unique identifier. %
On the other hand \ensuremath{\Conid{DocInfo}\;\Varid{a}} consists of the matching document and a
score. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{DocInfo}\;\Varid{a}\mathrel{=}\Conid{DocInfo}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{document}\mathbin{::}(\Conid{Document}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{docScore}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{Score}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{DocContextHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Context}\;\Conid{DocWordHits}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{DocWordHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Word}\;\Conid{Positions}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{DocHits}\;\Varid{a}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{DocIdMap}\;(\Conid{DocInfo}\;\Varid{a},\Conid{DocContextHits}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By default this score is calculated by the number of occurrences of
the search query in the document and represented as \ensuremath{\Conid{Float}}. %
But Holumbus also provides a mechanism to apply a customized ranking
function to calculate the score. %
\ensuremath{\Conid{WordHits}} illustrates the word completions and is represented by a
mapping of the possible completions of the given prefix in combination
with its score, i.e. \ensuremath{\Conid{WordInfo}}, and the contexts.\\
% Holumbus also provides a data structure that is returned after a query

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{WordInfo}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{WordInfo}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}\{\mskip1.5mu \Varid{terms}{}\<[29]%
\>[29]{}\mathbin{::}\Conid{Terms}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{},\Varid{wordScore}\mathbin{::}\Conid{Score}{}\<[E]%
\\
\>[16]{}\hsindent{1}{}\<[17]%
\>[17]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{WordHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Word}\;(\Conid{WordInfo},\Conid{WordContextHits}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{WordContextHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Map}\;\Conid{Context}\;\Conid{WordDocHits}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{WordDocHits}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{Occurrences}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


Summing up, we have discussed the mechanism to evaluate a query with
the Holumbus framework. %
The provided mechanism includes the data structures to represent a
query, which can be processed to a data structure consisting of the
matching documents and possible word completions. %
% But first the user input has to be parsed into the query structure to
% start the processing.

\section{Parsing User-Queries}\ref{analysis:parser}
% Which criteria do we want to search for? Modules, functions, types,
% signatures, and  det./non-det., flexible/rigid functions. \\
The next question is how to construct the query for a given
user-input. %
At first we have to decide about the criteria users can search for. %
Since the index provides the pairs of contexts and search words, we
are able to restrict the search to all these context with the help of
the \ensuremath{\Conid{Query}} data structure and the \ensuremath{\Conid{Specifier}} constructor. %
This structure of the index allows us to search for modules,
functions, types, signatures and all other contexts we use during the
creation of the index.\\

% First describe the idea, that the use of a specific language increases
% the usability. But it also restricts the user in her usage of the
% search engine, if this language gets more complex. So this results in
% a compromise between a simply to use language and a language that can
% be parsed.  Show the example of searching IO, where the restriction to
% modules minimizes the result.\\
The search mechanism as part of the user-experience is supposed to be
as simple as possible. %
The use of a specific language increases the usability, since an
expression has its explicit syntax. %
A good example is the search term \ensuremath{\text{\tt ''}\;\Varid{io''}}, since in Curry \emph{IO}
is the name for a module, a type and a constructor. %
Furthermore there are many functions in the IO module, that contain
the word \emph{io}. Thus, the search for \emph{io} results in a great
amount of hits. %
We can restrict the search to a specific context to reduce the number
of hits. %
Therefore we want to provide specifiers the user combinats with the
search term, for example \ensuremath{\text{\tt ''}\mathbin{:}\Varid{function}\;\Conid{IO''}} searches for \emph{IO} in
the context of function names only. %
But this special syntax restricts the user in the use of the search
engine, if the language gets more complex. %
Thus to provide a user-friendly search engine, we have to make a
compromise between a simply to use language and a language that can be
parsed. %

% Set the focus on signatures. Because Hayoo! does not find signatures with
% redundant parentheses, Curr(y)gle supports parenthesized signatures
% and parenthesized query parts in general. \\
Besides these specifiers we want to parse type signatures of Curry
functions and data structures. %
Since Hayoo! is not able to parse redundant parenthesized signatures,
we want to address this problem with great care. Let's assume a
beginner searches for a function with the type signature \ensuremath{\text{\tt ''}\;\Conid{IO}\to (\Conid{IO}\;\Conid{Int})\;\text{\tt ''}}. %
The type \emph{IO Int} and type constructors in general do not need
parentheses, but as beginner you might think they do. %
Thus we want to support parenthesized signatures and parenthesized
query parts in general. %

Last but not least we want to provide binary conjunctions like
\emph{And}, \emph{Or} and \emph{Not}. %
On the one hand a combination of more search words is desirable,
because popular search engines like Google\texttrademark~ support
binary operations as feature. %
The popularity increases the probability that users assume binary
operations are standard features and expect search engines to provide
the conjunction of several search terms. %
On the other hand if the desired result is still vague, a combination
of more search words by a disjunction \emph{Or} helps to narrow down
the search results.\\
% In addition: binary operations/conjunctions. \\
% Explain that in most cases, a combination of more search words is
% desirable, because first popular search engines like Google\texttrademark~use this
% feature so it's common knowledge (the user expects this features) and
% second it's easier to search for more search words, if the desired
% result is still vague.

In the end we want to provide an intuitive but powerful syntax for the
search engine. %
With specifiers to restrict the search results to a given context and
with binary operations to narrow down or extend the contexts, we want
to provide a simple language for the user queries. %
Additionally type signatures should be recognized, including function,
construction and primitive types as well as redundant parenthesized
signatures. %
As the number of the supported features increases, the query gets more
complex to read. %
Thus to reach this goal, we need to analyse the user input and rebuild
it as an expression of our \ensuremath{\Conid{Query}} data structure. %
In \hyperref[implementation:parser]{Section
  \ref{implementation:parser}} we discuss our actual implementation. %

% The parser becomes a complex, but very important matter.
\chapter{Implementation}\label{implementation}
% Mention that the implementation is done in Haskell or Curry.\\
% Give a short summary of the next sections.

This chapter presents the implementation of the search engine on the
basis of some code examples and the corresponding design ideas and
decisions. %
At first we take a look at the extension for the current version of
CurryDoc. %
In this context we illustrate the interaction between this extension
and the index creation. %
The latter determines the topic of the second section. %
We specify the index and document data in more detail and state some
difficulties that arose due to the usage of the Holumbus framework. %
The third section addresses the implemented parser to convert the user
input into a query that can be processed by Holumbus. %
We illustrate the general idea and implementation approach of a parser
to introduce into the subject. %
The last section covers features and implementations of the web
application for the search engine. %
The implementations are mostly written in the functional programming
language Haskell; we use the functional logic programming language
Curry for the CurryDoc extension only.\\

\todo[inline]{general section about the underlying environment?}

\section{CurryDoc Extension}\label{implementation:currydoc}

In the previous chapter we discussed the general idea of an extension
for CurryDoc to generate a data structure. %
Later this data structure serves as source for the index creation.%
In this section we take a look at the implementation of this
extension.

% Present the general structure of the |CurryInfo| data and the
% sub-structures |ModuleInfo|, |FunctionInfo| and |TypeInfo|.
Since CurryDoc is written in Curry, we implemented our extension in
Curry as well. %
With this decision we stand to benefit from already implemented
functionalities and on the other hand, using the same programming
language simplifies the integration of our implementation with the
current CurryDoc version.\\

CurryDoc uses the meta-programming language FlatCurry to gain an
intermediate data structure. %
We can use this data structure for our purposes. %
Additionally, we can use other functions provided by CurryDoc, that
are already implemented. %
For example, CurryDoc supports a special comment syntax to annotate
the author and version of a module. %
Furthermore the arguments and the return value of a function can be
described as well as general descriptions.

But at first, we discuss which information we want to provide in our
data structures. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{CurryInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{CurryInfo}\;\Conid{ModuleInfo}\;[\mskip1.5mu \Conid{FunctionInfo}\mskip1.5mu]\;[\mskip1.5mu \Conid{TypeInfo}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We already introduced \emph{CurryInfo} as structure for a Curry
program in the \hyperref[preliminaries:currydoc:curryInfo]{second
  chapter}. %
As next step we want to describe \ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}} and
\ensuremath{\Conid{TypeInfo}}, since they are a part of the \ensuremath{\Conid{CurryInfo}} data structure. %
% You can take a look at these data structures and their definitions in
% advance in \hyperref[fig:curryInfo]{Figure \ref{fig:curryInfo}}.

% \begin{figure}[h]
% \begin{code}
% -- || The CurryInfo data holds information about the module, and
% --  corresponding  functions, data and type declaration of a given 
% --  Curry module.
% data CurryInfo = 
%   CurryInfo ModuleInfo [FunctionInfo] [TypeInfo]
% %//%
% -- || ModuleInfo holds information about the name, author,
% --    and the description of a given module.
% data ModuleInfo = 
%   ModuleInfo String String String
% %//%
% -- || FunctionInfo holds information about the name, signature, corresponding 
% -- module, description and flexible/rigid status of a function and 
% -- its non-/deterministic behaviour.
% data FunctionInfo = 
%   FunctionInfo String (QName, TypeExpr) String String Bool
%   FlexRigidResult
% %//%
% -- || TypeInfo holds information about the name, signature, type variables,
% -- corresponding module, and description of a given type.
% data TypeInfo = 
%   TypeInfo String [(QName, [TypeExpr])] [Int] String String
% \end{code}
% \caption{The data structures representing a Curry program}
% \label{fig:curryInfo}
% \end{figure}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{ModuleInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ModuleInfo}\;\Conid{String}\;\Conid{String}\;\Conid{String}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Like the name suggests, \ensuremath{\Conid{ModuleInfo}} represents the data corresponding
to a Curry module. %
The main information about a module consists of its name, author and
description. %
We can also provide the version number of the implementation or the
imported modules, but we decided against it. %
The latter seems to be useless information for the search engine,
since the Curry modules are highly interrelated. %
Thus, searching for a module results in a great amount of hits, since
every correlating module will be shown as well. %
Furthermore we think the version number is not a significant
characteristic for a module. %
Therefore we decided to focus on the three mentioned proporties only.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{FunctionInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FunctionInfo}\;\Conid{String}\;(\Conid{QName},\Conid{TypeExpr})\;\Conid{String}\;\Conid{String}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FlexRigidResult}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\ensuremath{\Conid{FunctionInfo}} consists of characteristics for a given function like
the function's name and description. %
Additionally we decide to add the corresponding module to provide a
connection between the function and its module. %
This decision is based on the cause that we do not keep the
\ensuremath{\Conid{CurryInfo}} data structure as whole for the index construction, but
the three arguments consisting of the list of functions, the list of
types and the module information. %
Thanks to FlatCurry, we can also access function characteristics like
nondeterminism and determinism, along with the information if a given
function is rigid or flexible. %
Since these are important characteristics to differ between Curry
functions, \ensuremath{\Conid{FunctionInfo}} stores these information as property. %
In addition FlatCurry provides a data structure \ensuremath{\Conid{TypeExpr}} to describe
type signatures (see \hyperref[fig:typeExpr]{last chapter}),
furthermore we get the actual definition of a function. %
We use a function's type signature as part of the \ensuremath{\Conid{FunctionInfo}} data
structure, but decided against the usage of a function's definition
since we could not think of a relevant use-case for our search engine.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{TypeInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{TypeInfo}\;\Conid{String}\;[\mskip1.5mu (\Conid{QName},[\mskip1.5mu \Conid{TypeExpr}\mskip1.5mu])\mskip1.5mu]\;[\mskip1.5mu \Conid{Int}\mskip1.5mu]\;\Conid{String}\;\Conid{String}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The data structure for types looks quite similar to \ensuremath{\Conid{FunctionInfo}}. %
\ensuremath{\Conid{TypeInfo}} consists of a type's name, description and corresponding
module. %
Since FlatCurry provides type signatures for functions, we also get
information about constructors for a given type. %
Therefore we store a list of \ensuremath{\Conid{TypeExpr}} representing the type's
constructors. %
Additionally \ensuremath{\Conid{TypeInfo}} holds a list of integer to represent possible
type variables. %
The decision to use integer corresponds to the definition of
\ensuremath{\Conid{TypeExpr}}, where type variables are represented as integer as well.\\

In the end, we feed the \ensuremath{\Conid{CurryInfo}} data structure with the specific
module, function and type information of a given Curry program and our
CurryDoc extension writes the data structure into a
\emph{.cdoc}-file. %
The final CurryDoc version allows two mechanisms to generate the
\ensuremath{\Conid{CurryInfo}} structure. %
You can generate the \emph{.cdoc}-file only or you initiate the HTML
generation, where the \emph{.cdoc}-file is also part of the output. %
In \hyperref[a:currydoc]{Appendix \ref{a:currydoc}} we provide further
instruction for the usage of CurryDoc.

Due to the similar syntax, we can use the same data structures in
Haskell as in Curry to exchange those structures. %
More precisely, we can read the \emph{.cdoc}-file within our Haskell
implementation and work with the data structure. %
In order to do that, we need a Haskell program that defines all the
data structures used in \ensuremath{\Conid{CurryInfo}} including the nested structures. %
Thus, we generate \ensuremath{\Conid{CurryInfo}} to use it as data structure in the
process of the index creation.
% The same data structure is used on the Haskell side that implements
% the search engine.

\section{CurryIndexer Implementation}\label{implementation:index}

This section illustrates how to create the index for our search
engine. % In the following we refer to this process as indexer. %
In our analysis, we discussed some data structures to handle the index
creation and the information we want to store. %
In the following, we talk about the advantages and disadvantages of
using the Holumbus framework and describe our implementation of the
index creation in more detail. %
The following implementation is done in the functional logic
programming language Haskell. %
This decision allows us to use the Holumbus framework for our purpose
and a good number of functional, pure and strict features.\\

In the previous section we already mentioned the required preparation
to create the index. %
On the Haskell side, we need to define the data structures we use to
build the \ensuremath{\Conid{CurryInfo}} structure. %
Then we can read the file produced by the CurryDoc extension for
further usage. %
Since \ensuremath{\Conid{CurryInfo}} and its substructures \ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}}
and \ensuremath{\Conid{TypeInfo}} already provide the information we want to store in our
index, it is not necessary to filter these structures. %
Instead, we only have to process these data to fit the data structures
provided by Holumbus. %
In the end we can either create a new index by writing each structure
to a file to store our information or update an existing index with
additional Curry modules. %
In order to do that, we load the index and document files and merge
them with new data. %
Due to lazy evaluation, we cannot read and write to the same file; it
is not assured that we finish reading before we start to rewrite the
file. %
Therefore we have to write temporary files and rename these files
afterwards to guarantee a clean outcome.

During the testing phase of the indexer, we noticed problems regarding
duplicate data. %
In particular, when we add a Curry module to the index twice, there is
no mechanism to detect the duplicated data. %
For that reason only we added a list of the modules that are stored in
the index as output file. %
So every time we update the index with a given module, we check if it
already exists in the saved list. %
We only start the processing of the data, if the module does not occur
in our list and on the other hand, we add the module's name to the
list.\\

In the previous chapter, we introduced the idea of storing two
structures: an index \ensuremath{\Conid{Inverted}} and a document \ensuremath{\Conid{Documents}\;\Varid{a}}. %
In the following, we present this idea in more detail, beginning with
the index. %

\subsection{Index Construction}
As mentioned before, the main idea behind the index data structure is
to manage pairs of \ensuremath{\Conid{String}}. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Pair}{}\<[15]%
\>[15]{}\mathrel{=}(\Conid{Context},\Conid{Word}){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Word}{}\<[15]%
\>[15]{}\mathrel{=}\Conid{String}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Context}{}\<[15]%
\>[15]{}\mathrel{=}\Conid{String}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The first entry describes the context and the second entry stands for
the actual word, we want to store in the index. %
Both are represented as \ensuremath{\Conid{String}}.%
In the background, Holumbus data structure \ensuremath{\Conid{Inverted}} maps the words
to their location, i.e. the document. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Inverted}{}\<[18]%
\>[18]{}\mathrel{=}\Conid{Map}\;\Conid{Pair}\;\Conid{Occurrence}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Occurrence}{}\<[18]%
\>[18]{}\mathrel{=}\Conid{Map}\;\Conid{DocId}\;\Conid{Positions}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Positions}{}\<[18]%
\>[18]{}\mathrel{=}\Conid{IntSet}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{DocId}{}\<[18]%
\>[18]{}\mathrel{=}\Conid{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

More precisely, \ensuremath{\Conid{Inverted}} maps the word and its context to an
\ensuremath{\Conid{Occurrence}}, which on the other hand maps a reference to a document
(\ensuremath{\Conid{DocId}}) and its \ensuremath{\Conid{Positions}}. %
With these \ensuremath{\Conid{Positions}} that consist of a set of \ensuremath{\Conid{Int}}, we can
reconstruct a phrase of document. %
However, we only need these \ensuremath{\Conid{Positions}}, if we want to provide phrase
queries. %
Since our main goal is to provide the search signature or function,
module and types name, we decided against the support of phrase
queries. %
Therefore, we do not use the \ensuremath{\Conid{Position}} when indexing our data. %
The code examples just illustrate a sketch of the idea behind the
\ensuremath{\Conid{Inverted}} structure, the actual implementation does not matter for
our implementation, since we mostly use the provided interface. %
Furthermore the words are stores in prefix tree, which only allows
prefix search like we mentioned before. %

% \begin{figure}[h]
% \begin{code}
% type Inverted   = Map Pair Occurrence
% type Occurrence = Map DocId Positions
% type Positions  = IntSet
% type DocId      = Int
% type Pair       = (Context, Word)
% type Word       = String
% type Context    = String
% \end{code}
% \caption{Sketch for |Inverted| in Haskell syntax}
% \label{fig:inverted}
% \end{figure}

Due to the prefix search, we came across some difficulties which we
discuss later. %
Nevertheless, when we implement the indexing, we can make use of a function
provided by Holumbus that allows to create the index structure from a
list. %
Simply put, this list consists of a triple: the pair of \ensuremath{\Conid{String}}s and
a reference to the document we are indexing. %
When we index the \ensuremath{\Conid{CurryInfo}} structure, we examine its substructures
\ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}} to gain the characteristic
information. %
In this process, all information are paired with a context and the
contexts' names correspond to the information in these
substructures. %
For instance, in \ensuremath{\Conid{ModuleInfo}} we keep the module's name, author and
description; therefore we have our first contexts, named
\emph{\textss{module}} for the name, \emph{\textss{author}} and
\emph{\textss{description}} (see \hyperref[t:modcontext]{Table
  \ref{t:modcontext}}). %
We do not have much to do for a module's name, but since a module can
be written by several authors, we have to add a context for each
author stored in \ensuremath{\Conid{ModuleInfo}}. %

\begin{table}[h]
\centering{
\begin{tabular}{|l|l|l|}
\hline \multicolumn{2}{|c|}{ModuleInfo} \\
\hline property & context name \\
name & "module''\\
author & "author''\\
description & "description"\\
\hline
\end{tabular}
}
\caption{The contexts for a \ensuremath{\Conid{ModuleInfo}} data structure}
\label{t:modcontext}
\end{table}

Since we only have a representation as \ensuremath{\Conid{String}}, we need to process
the string containing the author information. %
In fact, the representation is not the main problem; the prefix search
frustrates the usage of the whole string as word for our index. %
If we search for an author named \emph{\textss{Duck}}, we will not
find \emph{\textss{Donald Duck}} since the search word
\emph{\textss{Duck}} is not a prefix. %
Therefore we have to spilt the \ensuremath{\Conid{String}} on whitespace to gain and add
all parts individually. %
A similar problem applies to the description, so we split the
description on whitespace too. %
In addition, we filter biased words that are shorter than two
characters to minimize redundant or, more precisely, useless data in
the index. %
The same preparation and context names hold for the name of a function
and its description in \ensuremath{\Conid{FunctionInfo}} and the type's name and
description in \ensuremath{\Conid{TypeInfo}}. %
Both structures hold their corresponding module's name that we want to
add to the index. %
At first we used the same context as for the name in \ensuremath{\Conid{ModuleInfo}}. %
However, we want to distinguish between a search for a module's name
and a function or data structure in a specific module. %
Therefore we decide to use two different contexts: one for
\ensuremath{\Conid{ModuleInfo}} that we already introduced and the second one in the
context of a corresponding module for a function or data structure;
for the latter we use \emph{\textss{inModule}}. %
Next we take a look at signatures, where we have the same problems due
to the prefix search. %
As first step, we convert the \ensuremath{\Conid{TypeExpr}} we store in \ensuremath{\Conid{FunctionInfo}}
and \ensuremath{\Conid{TypeInfo}} into a valid type signature that is consistent to the
Curry syntax. %
This conversion yields a \ensuremath{\Conid{String}} for further processing. %
Now let's assume we want to search for a function that yields the type
\ensuremath{\Conid{HTMLExp}}. %
The first idea is to search for \emph{\textss{:type HTMLExp}} and look
for further information in the documentation. %
The problem is, we do not want the user to look for information in the
documentation, we rather want to provide a mechanism to cover this
scenario. %
Since we provide type signatures, the user can search for \ensuremath{\Conid{HTMLExp}} in
signatures to get information about all the functions (and data
structures) that consist of the type \ensuremath{\Conid{HTMLExp}}. %
Unfortunately, in order to provide this behaviour we have to modify
the signatures too. %
Due to the prefix search we can only search type signatures that begin
with \ensuremath{\Conid{HTMLExp}}, but a function's type signature that yields the type
\ensuremath{\Conid{HTMLExp}} ends with \ensuremath{\Conid{HTMLExp}}. %
The first idea is to split a given type string like \ensuremath{\Conid{String}\to \Conid{String}\to \Conid{HTMLExp}} on \ensuremath{\to } add each part to the context. As first
consequence, we lose function types like in \ensuremath{(\Conid{Int}\to \Conid{String})\to \Conid{String}\to \Conid{HTMLExp}}, because we get the partitions \ensuremath{(\Conid{Int},\Conid{String}),\Conid{String},\Conid{HTMLExp}}. %
Secondly, we cannot only add primitive or constructor types (like
\ensuremath{\Conid{String}} or \ensuremath{\Conid{Maybe}\;\Conid{Int}}) to the index, if we want to provide the
search for type signatures with at least one function arrow. %
Thus, we decided not to convert the \ensuremath{\Conid{TypeExpr}} to the corresponding
\ensuremath{\Conid{String}}, but to decompose the signature into all its valid suffixes
first.%
In this way, each suffix is paired with the context
\emph{\textss{signature}}, converted into a type signature represented
as \ensuremath{\Conid{String}} and added to the index. The conversion function takes a
list of types represented as \ensuremath{\Conid{String}}s, concatenate this list with the
function arrow \ensuremath{\to } between each element of the list and yields a
\ensuremath{\Conid{String}}. %
Since \ensuremath{\Conid{TypeInfo}} stores a list of \ensuremath{\Conid{TypeExpr}} representing its
constructors' type signatures, we have to apply the mentioned
mechanism to all \ensuremath{\Conid{TypeExpr}}. %
Additionally we have to add the constructor name to the index
manually, because it is not part of the \ensuremath{\Conid{TypeExpr}}, since its usage is
more similar to a function than to a type. %
\hyperref[t:typcontext]{Table \ref{t:typcontext}} summarizes the
contexts of \ensuremath{\Conid{TypeInfo}}, whereas there a still contexts of
\ensuremath{\Conid{FunctionInfo}} left to be discussed. %

\begin{table}[h]
\centering{
\begin{tabular}{|l|l|}
\hline \multicolumn{2}{|c|}{TypeInfo} \\
\hline property & context name \\
\hline name & "type''\\
 corres. module & "inModule''\\
 signature & "signature"\\
 description & "description"\\
\hline
\end{tabular}
}
\caption{The contexts for a \ensuremath{\Conid{TypeInfo}} data structure}
\label{t:typcontext}
\end{table}

We distinguish between non/-deterministic and flexible or rigid
functions. %
For each characteristic that applies to a function, we add the given
context to the index. %
In case of a deterministic and flexible function, we
add \ensuremath{(\text{\tt \char34 flexible\char34},\text{\tt \char34 ~\char34})} and \ensuremath{(\text{\tt \char34 det\char34},\text{\tt \char34 ~\char34})}. %
The summary of all contexts concerning a function is shown in
\hyperref[t:funcontext]{Table \ref{t:funcontext}}.

\begin{table}[h]
\centering{
\begin{tabular}{|l|l|}
\hline \multicolumn{2}{|c|}{FunctionInfo} \\
\hline  property & context name \\
\hline name & "function''\\
 corres. module & "inModule''\\
 signature & "signature"\\
 description & "description"\\
 \multirow{2}{*}{flexible/rigid} & "flexible'' \\  & "rigid' \\
\multirow{2}{*}{non/-deterministic} &  "nondet'' \\ & "det'' \\
\hline
\end{tabular}
}
\caption{The contexts for a \ensuremath{\Conid{FunctionInfo}} data structure}
\label{t:funcontext}
\end{table}

Summing up, we process \ensuremath{\Conid{CurryInfo}}'s substructures \ensuremath{\Conid{ModuleInfo}},
\ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}} to pair their information with a
context. %
The last \emph{unknown value} of the indexing process is the third
entry of the triple: the reference to the document. %
Thus, as next step we examine the design of a document and in this
context, we discuss the document's role and value as part of the
triple.

\subsection{Document Construction}

% At first, we take closer look at the data structure itself. %
% Holumbus provides us with |Documents a| can be described as mapping of
% yet another data structure |Document a| and an unique identifier (see
% \hyperref[fig:documents]{Figure \ref{fig:documents}}). %
% Each |Document a| consists of a title, an URI and customizable
% information. %
% The latter has the type |a| and determines the type for a document. %
% In order to have a faster access to a specific document, |Documents a|
% also stores the highest document id used in the mapping as well as a
% mapping from the document's uri to the document's identifier.

% \begin{figure}[h!]
% \begin{code}
% data Document a = Document
%                   { title  :: Title
%                   , uri    :: URI
%                   , custom :: (Maybe a)
%                   }
% %//%
% data Documents a = Documents
%                    { idToDoc   :: (DocMap a)   
%                    , docToId   :: URIMap
%                    , lastDocId :: DocId     
%                    }
% \end{code}
% \caption{Holumbus' data structure for a document and a collection of documents}
% \label{fig:documents}
% \end{figure}

At first, we take closer look at the data structure itself. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Documents}\;\Varid{a}\mathrel{=}\Conid{Documents}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{}\{\mskip1.5mu \Varid{idToDoc}{}\<[32]%
\>[32]{}\mathbin{::}(\Conid{DocMap}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{},\Varid{docToId}{}\<[32]%
\>[32]{}\mathbin{::}\Conid{URIMap}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{},\Varid{lastDocId}\mathbin{::}\Conid{DocId}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Holumbus provides us with \ensuremath{\Conid{Documents}\;\Varid{a}} that can be described as
mapping of yet another data structure \ensuremath{\Conid{Document}\;\Varid{a}} and an unique
identifier. %
Each \ensuremath{\Conid{Document}\;\Varid{a}} consists of a title, an URI and customizable
information. %
The latter has the type \ensuremath{\Varid{a}} and determines the type for a document. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Document}\;\Varid{a}\mathrel{=}\Conid{Document}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\{\mskip1.5mu \Varid{title}{}\<[28]%
\>[28]{}\mathbin{::}\Conid{Title}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{},\Varid{uri}{}\<[28]%
\>[28]{}\mathbin{::}\Conid{URI}{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{},\Varid{custom}\mathbin{::}(\Conid{Maybe}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
                
In order to have a faster access to a specific document, \ensuremath{\Conid{Documents}\;\Varid{a}}
also stores the highest document id used in the mapping as well as a
mapping from the document's uri to the document's identifier. %

For the creation of the index, we have to feed \ensuremath{\Conid{Documents}\;\Varid{a}} with
actual data. %
As mentioned before, we can read the \ensuremath{\Conid{CurryInfo}} structure and use it
in the process. %
The first idea is to construct a document with \ensuremath{\Conid{CurryInfo}} as data
structure for the custom information. %
This idea is easy to implement since we just use the unmodified data
structure that CurryDoc produces. %
As consequence, all the information in the corresponding index map to
this one document. %
When we search our index for an information, we can relate a given
search result only to the corresponding \ensuremath{\Conid{CurryInfo}}; we cannot
distinguish if the search result is associated to the module, function
or type information of the given \ensuremath{\Conid{CurryInfo}} structure. %
In order to provide a more differentiated representation of a Curry
module in the index, we choose not to use \ensuremath{\Conid{CurryInfo}} but its
substructures \ensuremath{\Conid{ModuleInfo}}, \ensuremath{\Conid{FunctionInfo}} and \ensuremath{\Conid{TypeInfo}} as document
types, i.e. the custom information. %
However, if we want to distinguish between these three sources of
information, we need to store three types of documents. %
Nevertheless this decision allows us to relate the information of a
Curry module to its functions, types or information about the module
itself. %
Furthermore, we decide that a Curry module is converted into more than
this three documents. %
We rather want to create a document for each function and data
structure of a given Curry module plus the module's general
information. %
In the end, we trace back a search result to the exact function, data
structure or module information, since we can take advantage of the
devision of the \ensuremath{\Conid{CurryInfo}} data structure. %

This design already determines the decision regarding the title and
the URI. %
The title corresponds to the name of the function, type or module. %
The value of the URI is an argument to fill by the user when
generating the index; the URI can point to a local or online source
for documentation. %
We designed the URI representation for the HTML-documentation provided
by CurryDoc, since the current main source for Curry documentation,
that can be accessed
online\footnote{\url{http://www.informatik.uni-kiel.de/~pakcs/lib/CDOC}},
is generated via CurryDoc. %
Since this HTML-structure of a Curry module documentation provides
anchors to the module's defined functions and data structures, we use
this link mechanism for our URIs as well. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{URI}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ModuleURI}\;(\Varid{a}\to \Conid{String})\mid {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FctOrTypeURI}\;(\Varid{a}\to \Conid{String})\;(\Varid{a}\to \Conid{String}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The data structure \ensuremath{\Conid{URI}\;\Varid{a}} can describe an URI for a module and a type
or function. %
The first URI constructor takes a function that yields the module's
name for a \ensuremath{\Conid{ModuleInfo}} structure. %
The latter constructor takes two functions, the first to yield the
name of a function's or type's corresponding module and the second to
yield the function's or type's name. %
The function \ensuremath{\Varid{uriTypeToUriPath}\mathbin{::}\Conid{String}\to \Conid{URI}\;\Varid{a}\to \Varid{a}\to \Conid{String}} distinguishes
between the two constructors to build the URI and combines it with the URI
path given by the user.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{ModuleURI}\;\Varid{baseURI}\to {}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{uriPath}\plus \Varid{baseURI}\;\Varid{info}\plus \text{\tt \char34 .html\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the case of an URI for a module, we just combine the URI path with
the module's name and add the \emph{.html} extension.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{FctOrTypeURI}\;\Varid{baseURI}\;\Varid{name}\to {}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{uriPath}\plus \Varid{baseURI}\;\Varid{info}\plus \text{\tt \char34 .html\char34}\plus \text{\tt \char34 \#\char34}\plus \Varid{name}\;\Varid{info}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

On other hand, we construct the URI as above, add the anchor symbol
and the function's and types' name to generate the URI linking to the
documentation.
     
% \begin{figure}[h]
% \begin{code}
% doc :: String -> (a -> String) -> URI a -> a -> Document a
% doc uriPath fiName uriType info = Document 
%   { title  = fiName info
%   , uri    = uriP
%   , custom = Just info
%   }
%  where uriP = 
%    case uriType of
%      ModuleURI baseURI -> 
%        uriPath ++ baseURI info ++ ".html"
%      FctOrTypeURI baseURI name -> 
%        uriPath ++ baseURI info ++ ".html" ++ "#" ++ name info

% %//%
% data URI a = 
%   ModuleURI (a -> String) | 
%   FctOrTypeURI (a -> String) (a -> String)
% \end{code}
% \caption{A function to build |Document a| and the data structure to
%   distinguish between an URI with or without anchors}
% \label{fig:uri}
% \end{figure}


\subsection{Conclusion and Example}
All in all, we have a mechanism to create an index data structure that
is traversed, when we perform a search query and one mechanism to
store the corresponding document, that is linked to the index
structure again. %
We create these structures for the three substructures of \ensuremath{\Conid{CurryInfo}}
and combine them into a \ensuremath{\Conid{HolumbusState}\;\Varid{a}}, where \ensuremath{\Varid{a}} defines the type
of the document. %
In the end, each of the three \ensuremath{\Conid{HolumbusState}\;\Varid{a}} data structures are
written into a two files (separating index and document structure
again); these files serve aus our index. \\

Since we do not want or search engine to be build on just one Curry
program, we update the index with new data. %
We already adressed the problem concerning lazy evaluation, but we ran
into another problems as well. %
When we write the \ensuremath{\Conid{HolumbusState}\;\Varid{a}} structure into a file, the data is
compressed into structures named \ensuremath{\Conid{CompactInverted}} and \ensuremath{\Conid{SmallDocuments}\;\Varid{a}}. %
This means, when we load our files again, the index as well as the
document structures does not harmonize with \ensuremath{\Conid{Inverted}} and \ensuremath{\Conid{Documents}\;\Varid{a}} anymore. %
We solve this problem by creating the \ensuremath{\Conid{Inverted}} and \ensuremath{\Conid{Documents}\;\Varid{a}} as
usually and as second step, we convert \ensuremath{\Conid{Inverted}} into
\ensuremath{\Conid{CompactInverted}} and \ensuremath{\Conid{Documents}\;\Varid{a}} into \ensuremath{\Conid{SmallDocuments}\;\Varid{a}}. %
We cannot merge the structs just yet, since we created new documents
with identifiers starting with \ensuremath{\mathrm{1}}. %
We need to adapt the \ensuremath{\Conid{DocId}}s such that the minimum of the new
structure is the maximum of the old one. %
After that, we can merge the documents and index structure and write
the new file. \\

The following code serves as showcase for an index construction with
the information of a function. %
In the end we build a \ensuremath{\Conid{HolumbusState}\;\Conid{FunctionInfo}} structure. %


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fctState}\mathrel{=}\Varid{ixDoc}\;{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\Varid{contextsF}\;{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}(\Varid{functionInfos}\;\Varid{curryDoc})\;{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}(\Varid{map}\;(\Varid{doc}\;\Varid{uriPath}\;\Varid{fName}\;(\Conid{FctOrTypeURI}\;\Varid{fModule}\;\Varid{fName})){}\<[E]%
\\
\>[19]{}\hsindent{2}{}\<[21]%
\>[21]{}\mathbin{\$}\Varid{functionInfos}\;\Varid{curryDoc})\;{}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\Varid{cFct}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We have a \ensuremath{\Conid{CurryInfo}} structure named \ensuremath{\Varid{curryDoc}} and extract the
\ensuremath{\Conid{FunctionInfo}} structure through \ensuremath{\Varid{functionInfos}\;\Varid{curryDoc}}.

Next, we construct the pairs of contexts and words that we need
for the \ensuremath{\Conid{Inverted}} index structure; this behaviour is described by the
function \ensuremath{\Varid{contextsF}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{contextsF}\;\Varid{functionInfo}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}[\mskip1.5mu (\text{\tt \char34 :function\char34},\Varid{fName}\;\Varid{functionInfo})\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\plus [\mskip1.5mu (\text{\tt \char34 :inModule\char34},\Varid{fModule}\;\Varid{functionInfo})\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\plus (\Varid{signature}\mathbin{\$}\Varid{signatureComponents}\mathbin{\$}\Varid{fSignature}\;\Varid{functionInfo}){}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\plus (\Varid{flexRigid}\mathbin{\$}\Varid{fFlexRigid}\;\Varid{functionInfo}){}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\plus (\Varid{nonDet}\mathbin{\$}\Varid{fNonDet}\;\Varid{functionInfo}){}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\plus (\Varid{description}\mathbin{\$}\Varid{fDescription}\;\Varid{functionInfo}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The function \ensuremath{\Varid{description}} just pairs the
context with the given the data of \ensuremath{\Conid{FunctionInfo}}; %
\ensuremath{\Varid{flexRigid}} and \ensuremath{\Varid{nonDet}} do the same with the addition that they first
check, which context to apply; %
\ensuremath{\Varid{signatureComponents}} is the function that deconstructs a type
signature into valid suffixes and \ensuremath{\Varid{signature}} pairs all these suffixes
with the context. %

Since we are just building tuples, we add the reference to the
document as \ensuremath{\Conid{Occurrences}} to construct the required triple. %
We gain the \ensuremath{\Conid{DocId}} to build \ensuremath{\Conid{Occurrences}} when we insert a document
into a new \ensuremath{\Conid{Documents}\;\Varid{a}} structure. %
Therefore, we take a look at the document construction first. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{doc}\;\Varid{uriPath}\;\Varid{fiName}\;\Varid{uriType}\;\Varid{info}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Document}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{title}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{fiName}\;\Varid{info}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{uri}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{uriTypeToUriPath}\;\Varid{uriPath}\;\Varid{uriType}\;\Varid{info}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{custom}{}\<[13]%
\>[13]{}\mathrel{=}\Conid{Just}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The URI path is given by the user, the title of the document is the
function's name, which can be extracted by the provided function and
the \ensuremath{\Conid{URI}\;\Varid{a}} data structure determines the final URI. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\Varid{map}\;(\Varid{doc}\;\Varid{uriPath}\;\Varid{fName}\;(\Conid{FctOrTypeURI}\;\Varid{fModule}\;\Varid{fName})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbin{\$}\Varid{functionInfos}\;\Varid{curryDoc}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In our code, we create a document structure for all the functions in
\ensuremath{\Conid{CurryInfo}} and work a list of \ensuremath{\Conid{Document}\;\Conid{FunctionInfo}} in the further
process. %
Now we insert each document to a new \ensuremath{\Conid{Documents}\;\Conid{FunctionInfo}}
structure.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{insertDoc}\;\Varid{documents}\;\Varid{document}\mathbin{::}(\Conid{DocId},\Conid{Documents}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We use the \ensuremath{\Conid{DocId}} to add the \ensuremath{\Conid{Occurrences}} to each pair of our
contexts to gain the list of triples.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{contexts}\;\Varid{info}\;\Varid{docId}\mathrel{=}\Varid{map}\;(\lambda (\Varid{c},\Varid{w})\to (\Varid{c},\Varid{w},\Varid{occ}\;\Varid{docId}))\;(\Varid{contextsF}\;\Varid{info}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Luckily, the \ensuremath{\Conid{HolIndex}} interface provides a function to build an
\ensuremath{\Conid{Inverted}} structure from a list of these triples. %
In this example, we create a new index, therefore we provide the empty
index as basis. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{idx}\mathrel{=}\Varid{fromList}\;\Varid{emptyInverted}\;\Varid{contextsF}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the end, for each function we construct the corresponding \ensuremath{\Conid{Document}\;\Conid{FunctionInfo}}, insert it into a new \ensuremath{\Conid{Documents}\;\Conid{Function}} structure,
pair the contexts with the information about the function and add the
obtained \ensuremath{\Conid{DocId}} to gain the \ensuremath{\Conid{Inverted}} index. %
Then we merge one index after another and also insert new
corresponding \ensuremath{\Conid{Document}\;\Conid{FunctionInfo}} structures to \ensuremath{\Conid{Documents}\;\Conid{FunctionInfo}}. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ixDoc}\;\Varid{contextList}\;(\Varid{info}\mathbin{:}\Varid{infos})\;(\Varid{doc1}\mathbin{:}\Varid{docs})\;(\Conid{IndexerState}\;\Varid{ix}\;\Varid{dc})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{let}\;(\Varid{docId},\Varid{docs'})\mathrel{=}\Varid{insertDoc}\;\Varid{dc}\;\Varid{doc1}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Varid{idx'}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{mergeIndexes}\;\Varid{ix}\mathbin{\$}\Varid{idx}\;\Varid{contextList}\;\Varid{info}\;\Varid{docId}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{in}\;\Varid{ixDoc}\;\Varid{contextList}\;\Varid{infos}\;\Varid{docs}\;(\Varid{makeIndexerState}\;\Varid{idx'}\;\Varid{docs'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Since we can also merge the new created \ensuremath{\Conid{HolumbusState}\;\Conid{FunctionInfo}}
with existing data, we pass an empty \ensuremath{\Conid{HolumbusState}\;\Conid{FunctionInfo}} when
constructing a new index. %
In our example, we replace the parameter \ensuremath{\Varid{contextList}} with
\ensuremath{\Varid{contexts}}, \ensuremath{(\Varid{info}\mathbin{:}\Varid{infos})} with the given \ensuremath{\Conid{FunctionInfo}} structures,
\ensuremath{(\Varid{doc1}\mathbin{:}\Varid{docs})} are the corresponding \ensuremath{\Conid{Document}\;\Conid{FunctionInfo}} structures
and \ensuremath{\Conid{IndexerState}\;\Varid{ix}\;\Varid{dc}} is an empty \ensuremath{\Conid{HolumbusState}\;\Conid{FunctionInfo}}. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ixDoc}\;\anonymous \;\anonymous \;\anonymous \;\Varid{hs}\mathrel{=}\Varid{hs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If there are no more functions left to process, we return the
constructed \ensuremath{\Conid{HolumbusState}} structure. \\

In the end there are one requirement and two ways to build an index. %
The requirement is the generation of a \emph{.cdoc}-file for at least
one Curry program. %
Then you can start the indexing for the given file and the URI to the
corresponding documentation to either create a new index or to update
an existing one. %
We also provide a mechanism to read out a \emph{.txt}-file consisting
of pairs of paths to \emph{.cdoc}-files and the corresponding URI. %
Further information about the usage is provided in
\hyperref[a:currysearch]{Appendix \ref{a:currysearch}}. %

% First mention that the interesting parts (that we want to add to the
% index) are already filtered by the CurryDoc part. So the indexer only
% processes the information to the structure provided by the Holumbus
% framework (HolumbusState). First the .cdoc file is read and resolved
% into the index and document structure.

% Present the output (files) the indexer produces. In addition to that, say something
% about refreshing and checking the list of modules.

% After that introduce the concept of documents and index. Mention the
% three different kinds of documents for the three structures: module,
% function, type.
% \begin{code}
% -- || Pair of index and documents of the type ModuleInfo
% type CurryModIndexerState         = HolumbusState ModuleInfo

% -- || Pair of index and documents of the type FunctionInfo
% type CurryFctIndexerState         = HolumbusState FunctionInfo

% -- || Pair of index and documents of the type TypeInfo
% type CurryTypeIndexerState        = HolumbusState TypeInfo
% \end{code}

% Refer to the appendix, where the usage of the curryIndexer is
% explained.
 
\section{Parser}\label{implementation:parser}

In this section we discuss the general idea of a parser, connect this
idea with our search engine and develop a simple parser as example. %
The example addresses the problem of parsing expressions that can
occur with and without parentheses. %
We choose this example, because we need such a parser for the user
queries in our search engine, too. %
Furthermore, we introduce
\emph{Parsec}\footnote{\url{http://hackage.haskell.org/package/parsec}}\footnote{\url{http://legacy.cs.uu.nl/daan/parsec.html}},
a Haskell library to build a strong and fast parser. %
In this context, we present some code examples of our implementation
and outline the advantages of using Parsec as well as some
problems that occurred during the development. %

\subsection{General Idea and Usage}

A parser is used to analyze a given input and compose a new data
structure depending on the information of the input. %
Parsing is an important topic among functional programmers and hence
many papers discuss the development of parsers. %
The most popular approaches use monadic parsers \cite{monpars} since
they can parse context-sensitive grammers, but there also alternatives
using higher-order functions \cite{funcpar}. %

In general, we want the parser to take an input value and transform it
into another structure. Thus, a parser can be described as
follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Parser}\;\sigma \;\alpha \mathrel{=}\sigma \to \alpha {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

With the type definition above, we can run one parser on a given
input. %
The main idea behind parsing is to apply several parsers and combine
the results. %
In order to do that, the parser type needs a pair consisting of the
parsing result and the rest of the input, which was not parsed. %
Additionally, we need to consider that the parsing of an input is
ambiguous. %
This means, there can be more than one way to parse the input and it
is also possible that the input can be parsed at all. %
Thus, we extend the result type to a be a list of pairs, representing
the different parsing combinations or the empty list, if the parser
fails. %
This approach of lists as success values was introduce by Philip
Wadler\cite{successlist}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Parser}\;\sigma \;\alpha \mathrel{=}[\mskip1.5mu \sigma \mskip1.5mu]\to [\mskip1.5mu (\alpha ,[\mskip1.5mu \sigma \mskip1.5mu])\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Summing up, a parser is parametrized with the type to parse, in the
following used as \ensuremath{\sigma }, and the resulting type \ensuremath{\alpha }. %
The parser takes a list of \ensuremath{\sigma } and returns a list of
possible parsed structures and rest strings. %
These structures are pairs, where the first entry is the composed
result and the second entry represents the remaining input. %
An empty list denotes failure, whereas a non-empty list stands for
success. %

% Explain the general idea of parsers: a parser is used to analyze the
% user query with these different kinds of information. While parsing
% the string, a new data structure is composed for further use. This
% data structure is provided by the Holumbus framework and is used to
% start the process that returns the search results.

% Introduce the parser type that is parametrized with the type to parse and the
% resulting type.

In order to make use of more than one parser, we need parser
combinators. %
At first, we take a look at combinator for alternatives (also: choice combinator). %

% Explain the operator |(<||>)| that applies two parsers and concatenates the
% parsing results.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\rotatebox[origin=c]{90}{$\ominus$})\mathbin{::}\Conid{Parser}\;\sigma \;\alpha \to \Conid{Parser}\;\sigma \;\alpha \to \Conid{Parser}\;\sigma \;\alpha {}\<[E]%
\\
\>[B]{}\Varid{p}~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{q}\mathrel{=}(\lambda \Varid{ts}\to \Varid{p}\;\Varid{ts}\plus \Varid{q}\;\Varid{ts}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For a given input, we apply parser \ensuremath{\Varid{p}} first and concatenate the
resulting list with the result of the application of parser \ensuremath{\Varid{q}} to
the input. %
We get all possible combinations that can be parsed by parser \ensuremath{\Varid{p}} and
parser \ensuremath{\Varid{q}}. %

Additionally, we want to combine a sequence of parsers. %
There are three possibilities to combine two parses, the first two are
similar to the monadic bind operator \ensuremath{\sequ } and the third one follows
the same idea as \ensuremath{\bind } . %
We start with the latter combinator. The operator allows us to
sequence the parser and combine their results.

% Introduce the combination of two parsers that is similar to a monadic
% bind operator. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\circledast)\mathbin{::}\Conid{Parser}\;\sigma \;(\alpha \to \beta )\to \Conid{Parser}\;\sigma \;\alpha \to \Conid{Parser}\;\sigma \;\beta {}\<[E]%
\\
\>[B]{}\Varid{p}\circledast\Varid{q}\mathrel{=}\lambda \Varid{ts}\to [\mskip1.5mu (\Varid{f}\;\Varid{x},\Varid{ts}_{2})\mid (\Varid{f},\Varid{ts}_{1})\leftarrow \Varid{p}\;\Varid{ts},(\Varid{x},\Varid{ts}_{2})\leftarrow \Varid{q}\;\Varid{ts}_{1}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

At first, we apply the input to parser \ensuremath{\Varid{p}} and gain a tuple consisting
of \ensuremath{\Varid{f}\mathbin{::}\alpha \to \beta } and the rest of the input \ensuremath{\Varid{ts}_{1}\mathbin{::}\sigma }. %
Then we apply parser \ensuremath{\Varid{q}} on the rest input, which results to a further
tuple \ensuremath{(\Varid{x},\Varid{ts}_{2})\mathbin{::}(\alpha ,\sigma )}. %
Finally, we apply the gained function \ensuremath{\Varid{f}\;\Varid{x}\mathbin{::}\beta } and return it as
pair with the remaining input \ensuremath{\Varid{ts}_{2}}.

In order to actually use the binding operator, we have to apply a
function that determines the conversion. %

% Now show that a function has to be applied, to use the binding
% operator.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\circledS)\mathbin{::}(\alpha \to \beta )\to \Conid{Parser}\;\sigma \;\alpha \to \Conid{Parser}\;\sigma \;\beta {}\<[E]%
\\
\>[B]{}\Varid{f}~\circledS~\Varid{p}\mathrel{=}{}\<[15]%
\>[15]{}\lambda \Varid{ts}\to [\mskip1.5mu (\Varid{f}\;\Varid{x},\Varid{ts}_{1})\mid (\Varid{x},\Varid{ts}_{1})\leftarrow \Varid{p}\;\Varid{ts}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This function runs the parser \ensuremath{\Varid{p}} for a given input, applies the given
function to the first entry of the resulting pair and returns the
modified result. %

We define the other two sequence combinators to show the interaction
of the two functions \ensuremath{\circledast} and \ensuremath{\circledS}. %
The other twos equence combinators also take two parsers, but discard
one parser's result and return the other. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(*\!\!\!>)\mathbin{::}\Conid{Parser}\;\sigma \;\alpha \to \Conid{Parser}\;\sigma \;\beta \to \Conid{Parser}\;\sigma \;\beta {}\<[E]%
\\
\>[B]{}\Varid{p}~*\!\!\!>\Varid{q}\mathrel{=}(\mathbin{\char92 \char95 }\Varid{qResult}\to \Varid{qResult})~\circledS~(\lambda \Varid{ts}\to (\Varid{p}\circledast\Varid{q})\;\Varid{ts}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This function discards the result of the first parser and returns the
result of the second. %
Whereas the next function works the other way around: the second
result is discarded and we return the result of the first parser.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(<\!\!\!*)\mathbin{::}\Conid{Parser}\;\sigma \;\alpha \to \Conid{Parser}\;\sigma \;\beta \to \Conid{Parser}\;\sigma \;\alpha {}\<[E]%
\\
\>[B]{}\Varid{p}<\!\!\!*~\Varid{q}\mathrel{=}(\lambda \Varid{pResult}\;\anonymous \to \Varid{pResult})~\circledS~(\lambda \Varid{ts}\to (\Varid{p}\circledast\Varid{q})\;\Varid{ts}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


These function illustrate the fundamentals to build effictive
parsers. %
In order to get a better image of the usage, we present a small
example. %
In most cases you parse \ensuremath{\Conid{String}} as input, so we get the following type for our
parser. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Parser}\;\alpha \mathrel{=}\Conid{String}\to [\mskip1.5mu (\alpha ,\Conid{String})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

At first, we want to construct a parser to read a character and return
it in the resulting pair. %
Otherwise the parser returns an empty list for an empty \ensuremath{\Conid{String}} as
input. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parsePredicate}\mathbin{::}(\Conid{Char}\to \Conid{Bool})\to \Conid{Parser}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{parsePredicate}\;\Varid{predicate}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\lambda (\Varid{t}\mathbin{:}\Varid{ts})\to \mathbf{if}\;\Varid{predicate}\;\Varid{t}\;\mathbf{then}\;[\mskip1.5mu (\Varid{t},\Varid{ts})\mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu ([\mskip1.5mu \mskip1.5mu],\Varid{t}\mathbin{:}\Varid{ts})\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\Varid{parsePredicate}\;\anonymous \mathrel{=}\lambda \Varid{ts}\to [\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

With this function we can define simple parser like \ensuremath{\Varid{parseAny}} that
parses any alphanumeric characters, %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parseDigit}\mathbin{::}\Conid{Parser}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{parseDigit}\mathrel{=}\Varid{parseSymbol}\;\Varid{isAlphaNum}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

or \ensuremath{\Varid{parseT}} that parses the character \ensuremath{\Varid{t}}. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parseT}\mathbin{::}\Conid{Parser}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{parseT}\mathrel{=}\Varid{parseSymbol}\;(\Varid{t}==){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

One of the reasons we need to parse the user queries for our search
engine are signatures. %
Since Curry is a functional languages, the most important search terms
are the functions' names and functions' type signatures. %
Like we mentioned before, we especially want to parse redundant
parenthesized signatures or partial queries. %
The following code illustrates how to parse expressions that can occur
with or with parentheses. %
In this example, an expression a sequence of alphanumeric characters. %

% Present the concept by writing a parser for expressions with or without
% parentheses using |<||>| and |<*>|. `

With the same schema as above, we can construct a parser that reads an
open parenthesis and a parser that reads a close parenthesis. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parseOpen}\mathbin{::}\Conid{Parser}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{parseOpen}\mathrel{=}{}\<[14]%
\>[14]{}\Varid{parsePredicate}\;(\text{\tt '('}==){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parseClose}\mathbin{::}\Conid{Parser}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{parseClose}\mathrel{=}{}\<[15]%
\>[15]{}\Varid{parsePredicate}\;(\text{\tt ')'}==){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Next, we need to defined a parser for the expressions. %
Since we already have a parser for characters and we want to parse the
a \ensuremath{\Conid{String}}, the main idea is to parse a sequence of characters,
i.e. to combine a sequence of \ensuremath{\Varid{parsePredicate}}. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parseExpression}\mathbin{::}\Conid{Parser}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parseExpression}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\lambda \Varid{ts}\to (\lambda (\Varid{c},\Varid{cs})\to \Varid{c}\mathbin{:}\Varid{cs})~\circledS~{}\<[36]%
\>[36]{}(\Varid{parseAny}\circledast\Varid{parseExpression})\;\Varid{ts}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For a given input \ensuremath{\Conid{String}} we run \ensuremath{\Varid{parseAny}} that reads the first
character. %
Next, \ensuremath{\Varid{parseExpression}} is executed with the remaining input, hence we
read one character after another until the parsing fails or the input
is read entirely. %
The parsed characters are then composed to a list, so all in all, the
parser returns the parsed \ensuremath{\Conid{String}}, i.e. the expression. %

Finally, we want a parser to read a parenthesized expression, but
discard the parentheses. %
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parseParenExpression}\mathbin{::}\Conid{Parser}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parseParenExpression}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\lambda \Varid{ts}\to (\mathbin{\char92 \char95 }\Varid{expr}\;\anonymous \to \Varid{expr})~\circledS~(\Varid{parseOpen}\circledast\Varid{parseExpression}\circledast\Varid{parseClose})\;\Varid{ts}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

With these parser combinators, we read the open parenthesis first,
then the expression and finally the close parenthesis. %
The function to combine the three results just returns the result of
the expression. %
If we are more precisly, the parser above does not parse an expression
with \emph{or} without parentheses like we promised before. %
In order to fix the parser, we need to add the choice combinator. %
Additionally, we want to present the second implementation to discard
the read parenthesis. % 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parseParenExpression2}\mathbin{::}\Conid{Parser}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parseParenExpression2}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\lambda \Varid{ts}\to (\Varid{parseOpen}~*\!\!\!>\Varid{parseExpression}<\!\!\!*~\Varid{parseClose}){}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{parseExpression}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Summing up, we introduced the basic idea of parsers and implemented a
small parser that can read an expression with or without parentheses. %
In the following, we have to keep in mind that we build a strong parser
by combining several parses that parse substructures. %

\subsection{Query Parser}

In our implementation we use the Haskell library Parsec to
build the parser to read and analyze the user queries. %
The main idea of Parsec is to use parser combinators instead of parser
generators. % 
The latter can generate a parser for a given grammer, whereas the
combination of several parses correlates to the idea we presented
above. %

The Parsec library provides a set of parser combinators that look
similar to the operators we introduced above. %
Unfortunately, they do not perform the exact same task. %
Thus, we take a look at the functionality Parsec provides first. %

The choice combinator follows a deterministic predictive approach with
limited lookahead \cite{parsec1}, i.e. the parser \ensuremath{\Varid{p}~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{q}} only tries the second
parser \ensuremath{\Varid{q}}, if the first parser did not consumed any input. %
In order to gain the functionality that both parsers a applied to the
input, Parsec provides the function \ensuremath{\Varid{try}} that discards the read input
a parser, if it fails during parsing. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{parsePorQ}\mathbin{::}\Conid{Parser}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{parsePorQ}\mathrel{=}(\Varid{try}\;\Varid{p})~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{q}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Thus, the parser tries \ensuremath{\Varid{p}} first; if it succeeds, parser \ensuremath{\Varid{q}} is not
applied anymore; if it fails, the consumed input is discarded and
parser \ensuremath{\Varid{q}} is applied to the unmodified input. %

The sequence combinators \ensuremath{\circledast}, \ensuremath{<\!\!\!*} and \ensuremath{*\!\!\!>} as well as the operator
\ensuremath{\circledS} are not part of the Parsec library. %
These functions apply to general concepts of sequening (also:
application), that are provided by the \emph{Applicative} interface
\footnote{\url{http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html}}. %
The concept of applicative programming is an idea introduced by Conor
McBride and Ross Patterson \cite{applicative}. %
However, the parser type that Parsec implements is an instance of
Applicative, which means, without limitation, we can use these functions in our
implementation. \\ %

The Parsec library called our attention, since the Holumbus framework
uses the library to provide a simple parser. %
The parser handles binary operations like \ensuremath{\Conid{AND}}, \ensuremath{\Conid{OR}} and \ensuremath{\Conid{NOT}} for
user queries. %
In the \hyperref[analysis:parser]{previous chapter} we already
mentioned our requirements on a parser for user queries, therefore we
do not use Holumbus' parser, but implement our own parser. %
In \hyperref[a:syntax]{Appendix \ref{a:syntax}} we give an overview of
the language we provide for the user queries. %

The following code presentation focuses on our implementation of the
parser for signatures, since the signatures are the main reason we
decided to build a new parser. %
Furthermore, the implementation uses some special feature Parsec
provides that we want to share. \\ %

At first, we take a look at all kinds of type expression that can
compose a type signature. %

\begin{itemize}
\item type variables, i.e. \ensuremath{\Varid{a}}
\item primitive types, i.e. \ensuremath{\Conid{Int}}, \ensuremath{\Conid{Bool}}
\item type constructors, i.e. \ensuremath{\Conid{Maybe}\;\Conid{Int}}, \ensuremath{\Conid{IO}\;()}
\item function types, i.e. \ensuremath{\Conid{Int}\to \Conid{Bool}}
\item lists, i.e. \ensuremath{[\mskip1.5mu \Conid{Int}\mskip1.5mu]}
\item tuples, i.e. \ensuremath{(\Conid{String},\Conid{Int})}
\end{itemize}

We build our parser for type signatures using these substructures. %
Each item on the list needs to be analyzed by its own parser and step
by step, we combine all parsers according to valid Curry syntax. \\

If you take a closer look at the our list of type expression, you see
that all identifiers that we have to parse, start with an upper-case
letter, except for type variables. %
Thus, at first, we need a parser that reads all valid identifiers. %
Luckily, Parsec provides a feature to define the tokens that are used
by the language and compose a parser for these tokens. %
Tokens are constructs like white space, comments, identifiers,
reserved words, numbers or strings. %

The module \ensuremath{\Conid{ParsecToken}} exports a function \ensuremath{\Varid{makeTokenParser}} that
takes such an language definition as returns a record with a set of
lexical parsers. %
Every lexical parser already considers surrounding white spaces, hence
we do not need to consider white spaces when we use a field of the
language record. %
The following code shows our language definition for type signatures:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}c<{\hspost}@{}}%
\column{4E}{@{}l@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{signatureDef}\mathrel{=}\Varid{emptyDef}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{identStart}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{upper},{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{identLetter}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{alphaNum},{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{reservedNames}{}\<[21]%
\>[21]{}\mathrel{=}{}\<[24]%
\>[24]{}[\mskip1.5mu \text{\tt \char34 AND\char34},\text{\tt \char34 NOT\char34},\text{\tt \char34 OR\char34}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\mskip1.5mu\}{}\<[4E]%
\ColumnHook
\end{hscode}\resethooks

In order to define such a language, we take an empty definition record
and rewrite the fields we want to use. %
Identifier start with an upper case (we handle type variables
separately) and the consists of alphanumeric characters. %
The reserved names are words that are not allows to occur as name of
an type expression. %
Our parser also knows the binary operations \ensuremath{\Conid{AND}}, \ensuremath{\Conid{NOT}} and \ensuremath{\Conid{OR}} and
since they are starting with an upper character, they are potential
type expressions. %
Therefore we need the parser to fail on these reserved operations when
parsing type signatures. %

Before we examine the first substructure, we need to consider the type
of our parser. %
We are parsing a \ensuremath{\Conid{String}} into a \ensuremath{\Conid{TypeExpr}}, thus, in the definitions
we used above, the type of our parser corresponds to: %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{TypeExprParser}\mathrel{=}\Conid{Parser}\;\Conid{String}\;\Conid{TypeExpr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


The first substructure we want to parse is a primitive type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{primParser}\mathbin{::}\Conid{TypeExprParser}{}\<[E]%
\\
\>[B]{}\Varid{primParser}\mathrel{=}\Varid{prim}~\circledS~\Varid{sigIdentifier}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For primitive types we only need to consider one identifier and \ensuremath{\Varid{prim}}
wraps this identifier into a \ensuremath{\Conid{TCons}}-structure with no type
arguments\footnote{A little reminder: \ensuremath{\Conid{Int}} => \ensuremath{\Conid{TCons}\;(\text{\tt \char34 Prelude\char34},\text{\tt \char34 Int\char34})\;[\mskip1.5mu \mskip1.5mu]}}. %
In case of an n-ary type constructor, we parse at least one identifier
a white space and another type expression. %

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{consParser}\mathbin{::}\Conid{TypeExprParser}{}\<[E]%
\\
\>[B]{}\Varid{consParser}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}((\lambda \Varid{constr}\;\anonymous \;\Varid{expr}\to \Varid{cons}\;\Varid{constr}\;\Varid{expr}){}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}~\circledS~\Varid{sigIdentifier}{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\circledast\Varid{whitespace}{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\circledast\Varid{sepBy1}\;(\Varid{signatureTerm}\;\Conid{False}\;\Conid{False})\;\Varid{whitespace}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}~\rotatebox[origin=c]{90}{$\ominus$}~\Varid{specialConstructors}{}\<[E]%
\\
\>[B]{}\mathbf{where}\;\Varid{specialConstructors}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\lambda \Varid{constr}\to \Varid{cons}\;\Varid{constr}\;[\mskip1.5mu \mskip1.5mu])~\circledS~(\Varid{string}\;\text{\tt \char34 :\char34}\rotatebox[origin=c]{90}{$\ominus$}\Varid{string}\;\text{\tt \char34 []\char34}\rotatebox[origin=c]{90}{$\ominus$}\Varid{string}\;\text{\tt \char34 ()\char34}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

At first, we parse an identifier like we do for primitive types and
additionally, we need a white space and another type expression to
follow. %
The function \ensuremath{\Varid{sebBy1}} takes two parsers as arguments, where the second
parser is a separator that occurs between two tokens of the same
kind. %
At least one type signature (but no white space) needs to occur,
otherwise the parser \ensuremath{\Varid{sepBy1}} fails and altogether \ensuremath{\Varid{consParser}}
fails. %
Thus, In our case we parse at least two type expression separated by a
white space or just one type expression. %
The parser \ensuremath{\Varid{signatureTerm}} handles all the substructures we listed
above. %
The first boolean value indicates, if a constructor type may occur
without parentheses; the second \ensuremath{\Conid{Bool}} is \ensuremath{\Conid{True}}, if we are in the
process of parsing a list or tuple and \ensuremath{\Conid{False}} otherwise. %
At last, we need to consider special constructors like the list
constructors \ensuremath{\mathbin{:}} and \ensuremath{[\mskip1.5mu \mskip1.5mu]} that are defined in the Prelude as well as
the unit type \ensuremath{()}. %


% the parser does not check if the whole string was parsed -> better user-experience

% Give a definition of the language (EBNF(?) / appendix). 

% \begin{code} 
%  query := expr [ expr ] | expr bool expr | (expr)
%  expr := (expr) | specifier | signature | string
%  bool := "AND" | "OR" | "NOT" 
%  specifier :=  ":module" [ alphaNum ] | ":signature"  [ signature ]
%  |  ":function" [ alphaNum ] | ":flexible" | ":rigid" |  ":nondet" | ":det" 
%  signature := Upper alphaNum | function | constructor 
%  function := signature "->" signature  | lower "->" signature |
%  signature "->" lower
%  constructor := Upper alphaNum signature | Upper alphaNum lower
% \end{code}

\section{Web Application}
\chapter{Conclusion}\label{conclusion}
\section{Summary and Results}
\section{Outlook}

% Setze Numerierung wieder auf römisch zurück und setzte von oben fort
% Wert ist demnach der von 'roemisch'
\newpage
\pagenumbering{Roman}
\setcounter{page}{\value{roemisch}}

% Appendix, falls vorhanden
\appendix
\chapter{CurryDoc Instruction}\label{a:currydoc}
\section{Installation}

The installation requires a running Curry and curry2prolog system, we
recommend the PAKCS and
KICS2\footnote{\url{http://www-ps.informatik.uni-kiel.de/kics2/}}
implementation. \\

If you have a running Curry system, you can go on and modify the
included \emph{Makefile}. %
The first variable defines the path to your Curry implementation and
has to be modified. %
The following three stand for the provided libraries and the analysis
tool. %

\begin{tabbing}\tt
~CURRY\char61{}\char47{}path\char47{}to\char47{}your\char47{}CurryImplementation\\
\tt ~LIB\char61{}\char36{}\char123{}CURRY\char125{}\char47{}lib\\
\tt ~META\char61{}\char36{}\char123{}LIB\char125{}\char47{}meta\\
\tt ~ANADIR\char61{}\char36{}\char123{}CURRY\char125{}\char47{}tools\char47{}analysis
\end{tabbing}

The next path must link to the executable of your Curry implementation
and the last path must be modified to the directory of
the\emph{Makefile}.

\section{How-to-use}

You can either generate the \emph{.cdoc}-file itself or the HTML
representation, since the latter generates the \emph{.cdoc}-file as well.
 
\begin{tabbing}\tt
~\char36{}~currydoc~\char91{}\char45{}\char45{}nomarkdown\char93{}~\char91{}\char45{}\char45{}html\char124{}\char45{}\char45{}tex\char124{}\char45{}\char45{}cdoc\char93{}~\char60{}module\char95{}name\char62{}\\
\tt ~\char36{}~currydoc~\char91{}\char45{}\char45{}nomarkdown\char93{}~\char91{}\char45{}\char45{}html\char124{}\char45{}\char45{}tex\char124{}\char45{}\char45{}cdoc\char93{}~\\
\tt ~~~~\char60{}doc~directory\char62{}~\char60{}module\char95{}name\char62{}\\
\tt ~\char36{}~currydoc~\char91{}\char45{}\char45{}nomarkdown\char93{}~\char45{}\char45{}noindexhtml~\\
\tt ~~~~\char60{}doc~directory\char62{}~\char60{}module\char95{}name\char62{}\\
\tt ~\char36{}~currydoc~\char45{}\char45{}onlyindexhtml~\char60{}doc~directory\char62{}~\char60{}module\char95{}names\char62{}
\end{tabbing}

\chapter{Installation and Usage of Curr(y)gle}\label{a:currysearch}

\section{Installation}

This directory contains cabal-file, for the installation you simply
have to run cabal.

\begin{tabbing}\tt
~\char36{}~cabal~configure~\\
\tt ~\char36{}~cabal~build~\\
\tt ~\char36{}~cabal~install
\end{tabbing}

Alternatively you can use the provided \emph{Setup.hs}.
\begin{tabbing}\tt
~\char36{}~runhaskell~Setup\char46{}hs~configure\\
\tt ~\char36{}~runhaskell~Setup\char46{}hs~build\\
\tt ~\char36{}~runhaskell~Setup\char46{}hs~install
\end{tabbing}

\section{How-to-use}

The installation process creates to binaries: \emph{curryIndexer} and
\emph{curryServer}. %
The first creates the index for a given directory that contains at
least one \emph{.cdoc}-file and a corresponding URI. %
The \emph{.cdoc}-file can be generated with the extended CurryDoc for
a given Curry module, the URI is the corresponding HTML documentation
that also can be generated with CurryDoc. %
This package provides an example-directory with three Curry modules
generated with CurryDoc that provide some \emph{.cdoc}-files. %
So you can generate an index with these examples and the documentation
provided by PAKCS. %
The curryIndexer can either generate a new index or update the
existing one, to distinguish between these options, you can use the
flag \emph{- -n} for generating a new index and \emph{- -u} for
updating the index.

\begin{tabbing}\tt
~\char36{}~curryIndexer~\char46{}\char47{}example\char47{}CDOC\char95{}HTML~\\
\tt ~~~~http\char58{}\char47{}\char47{}www\char46{}informatik\char46{}uni\char45{}kiel\char46{}de\char47{}\char126{}pakcs\char47{}lib\char47{}CDOC\char47{}~\char45{}\char45{}n\\
\tt ~\char36{}~curryIndexer~\char46{}\char47{}example\char47{}CDOC\char95{}URL~\\
\tt ~~~~http\char58{}\char47{}\char47{}www\char46{}informatik\char46{}uni\char45{}kiel\char46{}de\char47{}\char126{}pakcs\char47{}lib\char47{}CDOC\char47{}~\char45{}\char45{}u\\
\tt ~\char36{}~curryIndexer~\char46{}\char47{}example\char47{}CDOC\char95{}XML~\\
\tt ~~~~http\char58{}\char47{}\char47{}www\char46{}informatik\char46{}uni\char45{}kiel\char46{}de\char47{}\char126{}pakcs\char47{}lib\char47{}CDOC\char47{}~\char45{}\char45{}u
\end{tabbing}

Since it can take a very long time to add each single module, you can
pass a \emph{.txt}-file as argument that consists of pairs of \emph{.cdoc-file} and
URI to generate the index.

\begin{tabbing}\tt
~\char36{}~curryIndexer~\char46{}\char47{}example\char47{}test\char46{}txt~\char45{}\char45{}n
\end{tabbing}

If you have generated an index, you can run the web application on your
localhost on a given port with the curryServer.

\begin{tabbing}\tt
~\char36{}~curryServer~\char45{}p~1337
\end{tabbing}

\chapter{User-Query Syntax}\label{a:syntax}

% Literaturverzeichnis
\bibliography{literatur/bib}

% Eidesstattliche Erklärung
% \input{extras/eidesstattliche}

\end{document}
